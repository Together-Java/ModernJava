[{"root": "/home/leonardo/Code/ModernJavaCodeRun", "config": {"book": {"authors": ["Together Java", "Contributions from the Java Community"], "description": " Book teaching how to write modern and effective Java. It is maintained by the community, anyone can contribute.", "language": "en", "multilingual": false, "src": "src", "title": "Modern Java"}, "output": {"html": {"edit-url-template": "https://github.com/Together-Java/ModernJava/edit/develop/{path}", "git-repository-url": "https://github.com/Together-Java/ModernJava", "live-reload-endpoint": "__livereload", "mathjax-support": true, "site-url": "/", "fold": {"enable": true, "level": 0}, "playground": {"editable": true}}}, "preprocessor": {"features": {"command": "python3 features.py", "java_21": false, "simple_io": false, "toplevel_anonymous_class": true}}}, "renderer": "html", "mdbook_version": "0.4.35"}, {"sections": [{"Chapter": {"name": "Prelude", "content": "# Prelude\n\nFirst of all, thank you for your time and for your patience.\n\nI know that when I was in school I never wanted to read a book\nand, except for [The Cay](https://en.wikipedia.org/wiki/The_Cay) and [Great Expectations](https://en.wikipedia.org/wiki/Great_Expectations), I\ngot away without having to.\n\nSo while it is hypocritical for me to ask this of you,\nplease read this book like a book and go from the start to the end, one section at a time.\n\nAt the end of each section\nthere will also be challenges. I want you to at least attempt all of them before moving on to the next section.\n\nThis book is written specifically for those folks that feel like giving up, like they are too stupid to get it,\nor like they didn't understand a damn thing their professor has said for the last three months.\n\nI see you. You are not stupid. This is not your fault.[^probably]\n\n[^probably]: probably.\n", "number": [1], "sub_items": [{"Chapter": {"name": "Asking for Help", "content": "# Asking for Help\n\nIf anything in this confuses you or feels intimidating please, please **reach out** to someone.\n\nIf you are in a position to, make use of your teacher. That is what they\nare there for.\n\nIf you are not, on every page there is a button in the top right\ncorner which you can click to ask a question.\n\nWhen you do, keep in mind these basic rules.\n\n## 1. You get what you pay for\n\nOften the people willing to help you will be volunteers.\n\nDo not expect them to do your\nassignments for you, do not expect them to be available at a moments notice, and accept\nthat they are under no obligation to help anyone or you in particular.\n\n## 2. Ask early\n\nIf you are struggling with something and you have a deadline in 5 hours, that might not\nbe enough time to do anything.\n\nAsking questions well before a deadline is best for all those involved.\n\n## 3. Don't Ask to Ask\n\nDon't ask to ask, nor only say hello, just ask your actual question right away.\n\nConsult [https://dontasktoask.com/](https://dontasktoask.com/) for what that means exactly.\n", "number": [1, 1], "sub_items": [], "path": "prelude/asking_for_help.md", "source_path": "prelude/asking_for_help.md", "parent_names": ["Prelude"]}}, {"Chapter": {"name": "Toy Problems", "content": "# Toy Problems\n\nAs you go through this book there will be a lot of what can be considered \"toy problems.\"\n\nThat is, you will be shown or asked to write programs that have no obvious real world use.\nThey will be similar in spirit to math problems like \"if you have 8 apples and I take 3, how many apples do you have left?\"\n\nThe intent is not for these to be annoying, although I am sure they will be. The intent is for these problems to help you build an understanding of mechanics and structure.\n", "number": [1, 2], "sub_items": [], "path": "prelude/toy_problems.md", "source_path": "prelude/toy_problems.md", "parent_names": ["Prelude"]}}, {"Chapter": {"name": "Lies", "content": "# Lies\n\nAt various points in this book I am also going to lie to you. Specifically I will\nmake lies of omission.\n\nIf there are five ways to do something, I might pretend that there is only one\nway to do it until I give you enough context so that I can talk about the other\nfour.\n\nThis can be particularly annoying if you are in a course that is teaching things\nin a different order or if you feel rushed to just get some project done.\n\nI get that. I just ask that you trust me and go in the sequence I am laying out.\nI am honestly trying to make it so that you end with a stronger understanding than\nyou would have otherwise.\n\nThere is the question mark in the top right of every page.\n", "number": [1, 3], "sub_items": [], "path": "prelude/lies.md", "source_path": "prelude/lies.md", "parent_names": ["Prelude"]}}], "path": "prelude.md", "source_path": "prelude.md", "parent_names": []}}, {"Chapter": {"name": "Getting Started", "content": "# Getting Started\n\nThere are a lot of ways to \"get set up\" to run Java code.\n\nFor the purposes of this book, I am going to recommend that you\nstart with [replit.com](https://replit.com).\n\nIt requires an internet connection and you will have to make an account, but\nof the available options it is the easiest to set up.\n\nIf you are in school and your teacher has helped you get set up in some other\nway it is okay to skip this section and just do it the way you were shown.\n\nAll that matters is that in the end you have the ability to run and\nedit the following code.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    System.out.println(\"Hello, World\");\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World\");\n    }\n}\n```\n\n~ENDIF\n\n## Step 1. Make an account\n\nGo to [replit.com](https://replit.com) and find the \"Sign Up\" button.\nWebsites change every now and then so these screenshots might be out of date.\n\n<img src=\"/getting_started/repl_signup_0.png\"\n     alt=\"Picture of the sign up button on replit's website\"\n     width = \"200\">\n\nClick it and sign up for an account.\n\n<img src=\"/getting_started/repl_signup_1.png\"\n     alt=\"Picture of the sign up form on replit's website\"\n     width = \"200\">\n\n## Step 2. Create a Java REPL\n\nFind the \"Create REPL\" button and click it.\n\n<img src=\"/getting_started/repl_1.png\"\n     alt=\"Picture of the create repl button on replit's website\"\n     width = \"200\">\n\nThen you should be presented with a menu that lets you search for the type of REPL to create.\nFind the Java template and click \"Create\".\n\n<img src=\"/getting_started/repl_2.png\"\n     alt=\"Unfilled in create from template menu on replit\"\n     width = \"200\">\n\n<img src=\"/getting_started/repl_3.png\"\n     alt=\"Filled in create from template menu on replit\"\n     width = \"200\">\n\n## Step 3. Run code\n\nYou should land on a screen with a big green run button, an open file called\n\"Main.java\", and a blank window labeled \"console\".\n\n<img\n~IF toplevel_anonymous_class\nsrc=\"/getting_started/repl_4_voidmain.png\"\n~ELSE\nsrc=\"/getting_started/repl_4.png\"\n~ENDIF\nalt=\"Picture of an unran hello world program\"\nwidth = \"800\">\n\nClick it and you should see the text `Hello, world!` appear under the console window.\n\n<img\n~IF toplevel_anonymous_class\nsrc=\"/getting_started/repl_5_voidmain.png\"\n~ELSE\nsrc=\"/getting_started/repl_5.png\"\n~ENDIF\nalt=\"Picture of a hello world program after running\"\nwidth = \"800\">\n", "number": [2], "sub_items": [], "path": "getting_started.md", "source_path": "getting_started.md", "parent_names": []}}, {"Chapter": {"name": "First Steps", "content": "# First Steps\n\nIf you made it through the [Getting Started section](./getting_started/hello_world.md) you've successfully run this program.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    System.out.println(\"Hello, World!\");\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n\n~ENDIF\n\nThis \"prints\" - not in the sense of a physical printer, but like \"displays on the screen\" -\nthe text `\"Hello, World!\"`.\n\nIts a tradition for this to be your first program in any language.\n~IF toplevel_anonymous_class\n\nWe aren't quite at the point where I can explain what `void main()` means, but\nall you need to know for now is that it is what Java looks for to know where to start the program.\n\n```java\nvoid main() {\n    < WRITE YOUR CODE HERE >\n}\n```\n\n~ELSE\n\nUnfortunately, for reasons that are impossible to explain with the context you have at this point,\nhalf of this probably reads as cryptic nonsense.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n```\n\nI don't _want_ it to stay cryptic nonsense, but until we get there all you truly need to know\nis that Java uses all of that to know where to start the program.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        < WRITE YOUR CODE HERE >\n    }\n}\n```\n\n~ENDIF\n\nSo for all intents and purposes, this is the whole program.\n\n```java\nSystem.out.println(\"Hello, World!\");\n```\n\nThis bit of magic here - `System.out.println` - is a \"statement\" that \"prints\" the text inside the `(` and `)` as well as a \"new line\" to the screen.\n\n`print` with new `l`i`n`e.\n\nIf you were to replace it with `System.out.print`, then the output would lack that new line. This makes the following program be functionally identical to the first.\n\n```java\nSystem.out.print(\"Hello, \");\nSystem.out.print(\"World\");\nSystem.out.println(\"!\");\n```\n\n~IF toplevel_anonymous_class\n\nWhich, when we add back `void main()`, looks like this.\n\n```java\nvoid main() {\n    System.out.print(\"Hello, \");\n    System.out.print(\"World\");\n    System.out.println(\"!\");\n}\n```\n\n~ELSE\n\nWhich, when we add back the part you are squinting past, looks like this.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.print(\"Hello, \");\n        System.out.print(\"World\");\n        System.out.println(\"!\");\n    }\n}\n```\n\n~ENDIF\n\nYou should get in the habit of, whenever you see some bit of code, trying to physically type it out, run it,\ntweak it, and play with it.\n\nSo try playing around with this program. If you are not actively engaging then the whole thing is a bit of a wash.\n", "number": [3], "sub_items": [{"Chapter": {"name": "Comments", "content": "# Comments\n\nAt various points, I am going to leave \"comments\" in the code. Comments are parts of the code that\nare solely there for a human to be able to read as an explanation and can be written in regular\nwords.\n\n## In-line commenting\n\n~IF toplevel_anonymous_class\n\n```java, no_run\nvoid main() {\n    // This prints hello world!\n    System.out.println(\"Hello, World!\");\n}\n```\n\n~ELSE\n\n```java, no_run\npublic class Main {\n    public static void main(String[] args) {\n        // This prints hello world!\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n\n~ENDIF\n\nThe rules for this are that if you see a `//`, everything after that in the same line\nis ignored.\n\nIf you put `//` in front of something that is \"code\" and not an English explanation we colloquially call that \"commenting out\" the line.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    System.out.println(\"Hello, World!\");\n    // The line that prints out goodbye is \"commented out\"\n    // System.out.println(\"Goodbye!\");\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n        // The line that prints out goodbye is \"commented out\"\n        // System.out.println(\"Goodbye!\");\n    }\n}\n```\n\n~ENDIF\n\nYou might want to do that at various points where you want to see what happens if you \"turn off\" parts of\nthe code.\n\n## Multi-line commenting\n\nIf you put `/*` in the code then everything up until the next `*/` will be treated as a comment. The distinction\nhere is that this style of comment can span multiple lines.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    /*\n        I have eaten\n        the plums\n        that were in\n        the icebox\n        and which\n        you were probably\n        saving\n        for breakfast\n        Forgive me\n        they were delicious\n        so sweet\n        and so cold\n    */\n    System.out.println(\"Hello, World!\");\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        /*\n            I have eaten\n            the plums\n            that were in\n            the icebox\n            and which\n            you were probably\n            saving\n            for breakfast\n            Forgive me\n            they were delicious\n            so sweet\n            and so cold\n        */\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n\n~ENDIF\n\nSo that's a mechanism you will see me use and you can use yourself however you see fit.\n", "number": [3, 1], "sub_items": [], "path": "first_steps/comments.md", "source_path": "first_steps/comments.md", "parent_names": ["First Steps"]}}, {"Chapter": {"name": "Semicolons", "content": "# Semicolons\n\nThe `;` at the end of each of those lines is a \"semicolon\".\n\n```java\n~IF simple_io\nprint(\"Hello, \"); // <-- this thing\n            //  ^\n~ELSE\nSystem.out.print(\"Hello, \"); // <-- this thing\n                       //  ^\n~ENDIF\n```\n\nIt indicates that the statement has finished. A \"statement\" is a line of code that \"does something.\"\nThe reason we call it a statement and not just a \"line of code\" is that it can technically span multiple lines and be\nmore complicated than these examples.\n\n```java\nSystem.out.print(\n    \"Hello, \"\n);\n```\n\nThe `;` at the end is needed so that Java knows that the statement is over.\nYou need to put a `;`\nat the end of every statement. If you do not, Java will get confused and your code will not work.\n\nIf you happen to have an extra semi-colon or two that is technically okay. It just reads it as an \"empty statement.\" It's pointless, but it is allowed.\n\n```java\nSystem.out.print(\n    \"Hello, \"\n);;\n```\n\nOr even\n\n```java\nSystem.out.print(\n    \"Hello, \"\n);\n\n  // Technically legal, but kinda sus\n\n  ;;;;;;;;;;;;;\n  ;;;        ;;\n  ;;;        ;;\n  ;;;;;;;;;;;;;\n  ;;   ;;;   ;;\n  ;;;;;;;;;;;;;\n  ; ;       ; ;\n  ; ;       ; ;\n  ;;;       ;;;\n```\n", "number": [3, 2], "sub_items": [], "path": "first_steps/semicolon.md", "source_path": "first_steps/semicolon.md", "parent_names": ["First Steps"]}}, {"Chapter": {"name": "Formatting", "content": "# Formatting\n\nYou may have noticed that after each `{` all the code that comes after it is \"indented\" in one \"level.\"\n\n~IF toplevel_anonymous_class\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n\n~ENDIF\n\n~IF toplevel_anonymous_class\n\n~ELSE\n\nThen, when there is a `}` everything is \"de-dented\" one level.\n\n~ENDIF\n\nI will kindly ask that you try to stick to this rule when writing your own code as well.\nIf you try to find help online and you haven't, it will be hard for people\nto read your code.\n\nThis is easier to show than to explain in detail. Just try to make your code look like this.\n\n\u2705\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    System.out.println(\"Hello, World!\");\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n\n~ENDIF\n\nAnd not like this.\n\n\u274c\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main()\n{\nSystem.out.println(\"Hello, World!\");}\n```\n\n~ELSE\n\n```java\npublic class Main\n    {\n    public static void main(String[] args)\n            {\n        System.out.println(\"Hello, World!\");\n            }\n    }\n```\n\n~ENDIF\n\nAnd keep in mind that this rule of thumb applies to every language constrict that requires a `{` and `}` many of which I will introduce later.\n", "number": [3, 3], "sub_items": [], "path": "first_steps/formatting.md", "source_path": "first_steps/formatting.md", "parent_names": ["First Steps"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nAt the end of each larger section, I am going to write down some things you can do\nto make sure you get what was just gone over.\n\nThe rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\n## Challenge 1\n\nWrite a program that prints your name twice. So if your name is \"Jasmine\", the output of the program should be this.\n\n```text\nJasmine\nJasmine\n```\n\n## Challenge 2\n\nWhat will this program output when run? Write down your guess and then try actually running it.\n\n~IF toplevel_anonymous_class\n\n```text\nvoid main() {\n    System.out.println(\"A\");\n    //System.out.println(\"B\");\n    System.out.println(\"C\");//\n    System.out.println(\"D\");\n    /*\n    System.out.println(\"E\");\n    System.out.println(\"F\");*/\n    System.out.println(\"G\");\n}\n```\n\n~ELSE\n\n```text\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"A\");\n        //System.out.println(\"B\");\n        System.out.println(\"C\");//\n        System.out.println(\"D\");\n        /*\n        System.out.println(\"E\");\n        System.out.println(\"F\");*/\n        System.out.println(\"G\");\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 3\n\nThere are four semicolons in this perfectly functional program. Delete one of them at random and see what the errors you get look like.\n\nHow could you use that error to figure out where you might have forgotten to put a semicolon?\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    System.out.println(\"Apple\");\n    System.out.println(\"Banana\");\n    System.out.println(\"Clementine\");\n    System.out.println(\"Durian\");\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Apple\");\n        System.out.println(\"Banana\");\n        System.out.println(\"Clementine\");\n        System.out.println(\"Durian\");\n    }\n}\n```\n\n~ENDIF\n", "number": [3, 4], "sub_items": [], "path": "first_steps/challenges.md", "source_path": "first_steps/challenges.md", "parent_names": ["First Steps"]}}], "path": "first_steps.md", "source_path": "first_steps.md", "parent_names": []}}, {"Chapter": {"name": "Local Variables", "content": "# Local Variables\n\nMechanically, the next thing to cover is \"variables\".\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    String boss = \"Jaqueline\";\n    System.out.println(boss);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String boss = \"Jaqueline\";\n        System.out.println(boss);\n    }\n}\n```\n\n~ENDIF\n\nA variable declaration has three components - the \"type\", the \"name\", and the \"initial value\".\n\n```java\n     String boss = \"Jaqueline\";\n//   type   name   initial value\n```\n\nIn this case, we are declaring a variable called \"boss\" and assigning it the initial value\nof `\"Jaqueline\"`. Its \"type\" is \"String\", which I'll explain in more detail a bit ahead.\n\nAfter you declare a variable and assign it a value, the \"name\" refers to the value on the right\nhand side and you can use that name instead of the value.\n\n```java\n// Does the same thing as System.out.println(\"Jaqueline\");\nString boss = \"Jaqueline\";\nSystem.out.println(boss);\n```\n", "number": [4], "sub_items": [{"Chapter": {"name": "Naming", "content": "# Naming\n\nIt is a social convention[^perry] that local variables be named `likeThis`.\n\nThat is if their name is one word, that word should be in lowercase.\n\n```java\nString apple = \"Red Delicious\";\n```\n\nIf it is multiple words, the first word should be lowercase\nand the others should start with a capital letter.\n\nThis convention is called `camelCase` because the capitals looks like the humps on a Camels back[^camel].\n\nJust like proper formatting, sticking to this style will increase your chances of\nsomeone online being able to help you with your code.\n\n[^perry]: [Trapped! By societal convention!](https://youtu.be/CnOWLuN37D8?t=64)\n[^camel]: And because doing this will increase your body's ability to retain water by ~34%\n", "number": [4, 1], "sub_items": [], "path": "variables/naming.md", "source_path": "variables/naming.md", "parent_names": ["Local Variables"]}}, {"Chapter": {"name": "Reassignment", "content": "# Reassignment\n\nAfter a variable is declared and assigned an initial value, that value can be later reassigned.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    String boss = \"Jaqueline\";\n    System.out.println(boss);\n    boss = \"Chelsea\"\n    System.out.println(boss);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String boss = \"Jaqueline\";\n        System.out.println(boss);\n        boss = \"Chelsea\"\n        System.out.println(boss);\n    }\n}\n```\n\n~ENDIF\n\nReassignments just involve the name and the new value. The type should not be redeclared.\n\n```java\n    boss = \"Chelsea\";\n//  name   new value\n```\n\nAfter a variable is reassigned, the value associated with the name will reflect\nthe new value from that point in the program onwards.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    String boss = \"Jaqueline\";\n    // This will output \"Jaqueline\"\n    System.out.println(boss);\n    boss = \"Chelsea\"\n    // But this will output \"Chelsea\"\n    System.out.println(boss);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String boss = \"Jaqueline\";\n        // This will output \"Jaqueline\"\n        System.out.println(boss);\n        boss = \"Chelsea\"\n        // But this will output \"Chelsea\"\n        System.out.println(boss);\n    }\n}\n```\n\n~ENDIF\n", "number": [4, 2], "sub_items": [], "path": "variables/reassignment.md", "source_path": "variables/reassignment.md", "parent_names": ["Local Variables"]}}, {"Chapter": {"name": "Delayed Assignment", "content": "# Delayed Assignment\n\nThe declaration of a variable and the assignment of its initial value can\nbe done separately.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    String contestWinner;\n    contestWinner = \"Boaty McBoatface\";\n\n    System.out.println(contestWinner);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String contestWinner;\n        contestWinner = \"Boaty McBoatface\";\n\n        System.out.println(contestWinner);\n    }\n}\n```\n\n~ENDIF\n\nIn which case the \"variable declaration\" will only have the \"type\" and \"name\" components.\n\n```java\n   String contestWinner;\n//  type  name\n```\n\nAnd the \"initial assignment\" will look identical to a \"re-assignment\".\n\n```java\n   contestWinner = \"Boaty McBoatface\";\n//   name            initial value\n```\n\nBefore an initial value is assigned to a variable, it is not allowed to be used.[^whydelay]\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    String contestWinner;\n    // This will not run, since Java knows that\n    // you never gave contestWinner an initial value.\n    System.out.println(contestWinner);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String contestWinner;\n        // This will not run, since Java knows that\n        // you never gave contestWinner an initial value.\n        System.out.println(contestWinner);\n    }\n}\n```\n\n~ENDIF\n\n[^whydelay]:\n    There is no direct use for separating declaration and initial assignment at this point,\n    but [it's a surprise tool that will help us later](https://knowyourmeme.com/memes/its-a-surprise-tool-that-will-help-us-later).\n", "number": [4, 3], "sub_items": [], "path": "variables/delayed_assignment.md", "source_path": "variables/delayed_assignment.md", "parent_names": ["Local Variables"]}}, {"Chapter": {"name": "Types", "content": "# Types\n\nWhen a variable is declared, it is given a type.\n\n```java\nString color = \"green\";\n```\n\nIn this case, the variable `color` is declared to have the type `String`.\nAfter this declaration, `color` cannot be assigned to a value that is not a `String`.\n\n```java\n// A number is not a String!\nString color = 8;\n```\n\nThis applies to all situations where a variable might be given a value,\nincluding delayed assignment and reassignment.\n\nOne mental model is that types are like shapes. If the type of something is a circle,\nyou can only put circles into it.\n\n```java\n\u25ef thing = \u25ef;\n```\n\nYou cannot put square pegs in that round hole.\n\n```java\n// If Java actually functioned in terms of shapes, this\n// would not work since a Square is not the same \"type\"\n// of thing as a Circle.\n\u25ef thing = \u25a2;\n```\n", "number": [4, 4], "sub_items": [], "path": "variables/types.md", "source_path": "variables/types.md", "parent_names": ["Local Variables"]}}, {"Chapter": {"name": "Final Variables", "content": "# Final Variables\n\nThere is an optional extra part to a variable declaration where you can\nmark a variable as \"final\", meaning its value can never be reassigned.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    final String coolestChef = \"Anthony Bourdain\";\n    System.out.println(coolestChef);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        final String coolestChef = \"Anthony Bourdain\";\n        System.out.println(coolestChef);\n    }\n}\n```\n\n~ENDIF\n\nIf you try to reassign a final variable, Java will not accept your program.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    final String coolestChef = \"Anthony Bourdain\";\n    System.out.println(coolestChef);\n\n    // I'm sorry, but no. Cool guy, but no.\n    coolestChef = \"Gordan Ramsey\";\n    System.out.println(coolestChef);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        final String coolestChef = \"Anthony Bourdain\";\n        System.out.println(coolestChef);\n\n        // I'm sorry, but no. Cool guy, but no.\n        coolestChef = \"Gordan Ramsey\";\n        System.out.println(coolestChef);\n    }\n}\n```\n\n~ENDIF\n\nThis is useful if you have a lot of lines of code and want the mental\ncomfort of knowing you couldn't have reassigned that variable at any\npoint between its declaration and its use.\n\n```java\nfinal String genie = \"Robin Williams\";\n// imagine\n// 100s of lines\n// of code\n// and it is\n// hard to\n// read all of it\n// at a glance\n// ......\n// ......\n// You can still be sure \"genie\"\n// has the value of \"Robin Williams\"\nSystem.out.println(genie);\n```\n\nVariables whose assignment is delayed can also be marked final.\n\n```java\nfinal String mario;\nmario = \"Charles Martinet\";\n```\n\nThe restriction is the same - after the initial assignment, the variable\ncannot be reassigned.\n\n```java\nfinal String mario;\n// An initial assignment is fine\nmario = \"Charles Martinet\";\n// But you cannot reassign it afterwards\nmario = \"Chris Pratt\";\n```\n\nThe downside to this, of course, is more visual noise. If a variable is only\n\"alive\" for a small part of the code, then adding `final` might make it harder\nto read the code, not easier.\n", "number": [4, 5], "sub_items": [], "path": "variables/final_variables.md", "source_path": "variables/final_variables.md", "parent_names": ["Local Variables"]}}, {"Chapter": {"name": "Inferred Types", "content": "# Inferred Types\n\nIn many cases, Java is smart enough to know what the type of a variable should be\nbased on what it is initially assigned to.\nIn these cases, you can write `var` in place of the type and let java \"infer\" what it should\nbe.\n\n```java\n// Since what is to the right hand side\n// of the = is in quotes, Java knows that\n// it is a String.\nvar theDude = \"Lebowski\";\nSystem.out.println(theDude);\n```\n\nYou cannot use `var` with variables whose assignment is delayed.\n\n```java\n// With just the line \"var theDude;\",\n// Java doesn't know enough to infer the type\nvar theDude;\ntheDude = \"Lebowski\";\nSystem.out.println(theDude);\n```\n\nYou can use `var` with `final` to make a variable whose type is inferred\nand cannot be reassigned.\n\n```java\nfinal var theDude = \"Lebowski\";\nSystem.out.println(theDude);\n```\n\nImportant to note that even if Java is smart enough to automatically know the type,\nyou might not be yet. There is no shame in writing out the type explicitly.\n\n```java\nString theDude = \"lebowski\";\n```\n", "number": [4, 6], "sub_items": [], "path": "variables/inferred_types.md", "source_path": "variables/inferred_types.md", "parent_names": ["Local Variables"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nRemember the rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\n## Challenge 1\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    String mascot = \"The Noid\";\n    System.out.println(mascot);\n    mascot = \"Pizza the Hut\";\n    System.out.println(mascot);\n    mascot = \"Little Caesar\";\n    System.out.println(mascot);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String mascot = \"The Noid\";\n        System.out.println(mascot);\n        mascot = \"Pizza the Hut\";\n        System.out.println(mascot);\n        mascot = \"Little Caesar\";\n        System.out.println(mascot);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 2\n\nWhy won't this code run? Make it run by only changing one line.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    String fruit;\n    fruit = \"apple\"\n\n    System.out.println(fruit);\n\n    final String vegtable = \"carrot\";\n\n    System.out.println(fruit);\n    System.out.println(vegtable);\n\n    fruit = \"orange\";\n    vegetable = \"celery\";\n\n    System.out.println(fruit);\n    System.out.println(vegtable);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String fruit;\n        fruit = \"apple\"\n\n        System.out.println(fruit);\n\n        final String vegtable = \"carrot\";\n\n        System.out.println(fruit);\n        System.out.println(vegtable);\n\n        fruit = \"orange\";\n        vegetable = \"celery\";\n\n        System.out.println(fruit);\n        System.out.println(vegtable);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 3\n\nWhat is the output of this code?\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    String a = \"A\";\n    String b = \"B\";\n\n    b = a;\n    a = b;\n    b = a;\n    a = b;\n\n    System.out.println(a);\n    System.out.println(b);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String a = \"A\";\n        String b = \"B\";\n\n        b = a;\n        a = b;\n        b = a;\n        a = b;\n\n        System.out.println(a);\n        System.out.println(b);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 4\n\nOnly adding lines in the middle and without writing `\"A\"` or `\"B\"` again,\nmake it so that the output of the program is\n\n```text\nB\nA\n```\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    String a = \"A\";\n    String b = \"B\";\n    // Don't touch above this\n\n    // You can add code here\n\n    // Don't touch below this\n    System.out.println(a);\n    System.out.println(b);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String a = \"A\";\n        String b = \"B\";\n        // Don't touch above this\n\n        // You can add code here\n\n        // Don't touch below this\n        System.out.println(a);\n        System.out.println(b);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 5\n\nSome of the variables in this program are named \"wrong.\" Fix them.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    String apple = \"red\";\n    String clown_car = \"polka dot\";\n    String SeriousCar = \"black\";\n    String FASTRunner = \"bolt\";\n    String slowRunner = \"tortoise\";\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String apple = \"red\";\n        String clown_car = \"polka dot\";\n        String SeriousCar = \"black\";\n        String FASTRunner = \"bolt\";\n        String slowRunner = \"tortoise\";\n    }\n}\n```\n\n~ENDIF\n", "number": [4, 7], "sub_items": [], "path": "variables/challenges.md", "source_path": "variables/challenges.md", "parent_names": ["Local Variables"]}}], "path": "variables.md", "source_path": "variables.md", "parent_names": []}}, {"PartTitle": "Data Types I"}, {"Chapter": {"name": "Booleans", "content": "# Booleans\n\nA `boolean` is either `true` or `false`.\n\n```java\nboolean onFleek = true;\nboolean badVibes = false;\n```\n\nThis is used to represent situations where there are exactly two possible states.\n", "number": [5], "sub_items": [{"Chapter": {"name": "And", "content": "# And\n\nOne way multiple booleans can be combined is by using the \"and\" operator - `&&`.\n\n```java\nboolean funToBeAround = true;\nboolean believesInFundamentalHumanRights = true;\nboolean willAskOnDate = funToBeAround && believesInFundamentalHumanRights;\n```\n\nSo in this case, I will ask someone on a date if they are fun to be around _and_\nthey wholeheartedly believe in the assertions made in the [Universal Declaration of Human Rights](https://www.un.org/en/about-us/universal-declaration-of-human-rights).\n\n| funToBeAround | believesInFundamentalHumanRights | willAskOnDate |\n| ------------- | -------------------------------- | ------------- |\n| true          | true                             | true          |\n| true          | false                            | false         |\n| false         | true                             | false         |\n| false         | false                            | false         |\n", "number": [5, 1], "sub_items": [], "path": "boolean/and.md", "source_path": "boolean/and.md", "parent_names": ["Booleans"]}}, {"Chapter": {"name": "Or", "content": "# Or\n\nAnother way booleans can be combined is by using the \"or\" operator - `||`.\n\n```java\nboolean dogLooksNice = true;\nboolean personLooksNice = false;\nboolean willAskToPetDog = dogLooksNice || personLooksNice;\n```\n\nSo in this case, I will ask to pet someone's dog if either the the dog looks nice _or_ the person\nwalking the dog looks nice.\n\n| dogLooksNice | personLooksNice | willAskToPetDog |\n| ------------ | --------------- | --------------- |\n| true         | true            | true            |\n| true         | false           | true            |\n| false        | true            | true            |\n| false        | false           | false           |\n\n## Exclusive vs. Inclusive\n\nIt is important too note that this is not an \"exclusive\" OR.\n\nAn exclusive OR would be something like\na child being allowed to have ice cream _or_ a cookie, but not both.\n\nThe `||` operator is an \"inclusive\" OR, meaning the child is allowed ice cream, a cookie, or both ice cream and the cookie.\n", "number": [5, 2], "sub_items": [], "path": "boolean/or.md", "source_path": "boolean/or.md", "parent_names": ["Booleans"]}}, {"Chapter": {"name": "Not", "content": "# Not\n\nBooleans can also be \"negated\" using the \"not\" operator - `!`.\n\n```java\nboolean haveOreosInHouse = true;\nboolean stuckToCalorieLimit = !haveOreos;\n```\n\nSo in this case, I have stuck to my calorie limit if there are _not_ Oreos in the house.\n\n| haveOreosInHouse | stuckToCalorieLimit |\n| ---------------- | ------------------- |\n| false            | true                |\n| true             | false               |\n", "number": [5, 3], "sub_items": [], "path": "boolean/not.md", "source_path": "boolean/not.md", "parent_names": ["Booleans"]}}, {"Chapter": {"name": "Operator Precedence", "content": "# Operator Precedence\n\nThe operators that work on booleans have a \"precedence order.\"\n\nThis is defines an order of operations similar to mathematics, where multiplication and division happen before\naddition and subtraction.\n\nFor booleans `!` always happens first. This is followed by `&&` and then by `||`.\n\n```java\nboolean a = true;\nboolean b = false\nboolean c = false;\n\n// just as 2 + 5 * 3 \"evaluates\" 5 * 3 before adding 2\n// first, !b is true\n// second, a && true is true\n// third true || c is true.\nboolean result = a && !b || c;\n```\n\nAlso like mathematics, parentheses can be used to control this order.\n\n```java\n// Even though || has a lower precedence than &&, we evaluate\n// !b || c first because of the parentheses.\nboolean result = a && (!b || c);\n```\n", "number": [5, 4], "sub_items": [], "path": "boolean/operator_precedence.md", "source_path": "boolean/operator_precedence.md", "parent_names": ["Booleans"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nRemember the rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\n## Challenge 1\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    boolean a = true;\n    boolean b = false;\n    boolean c = true;\n    boolean d = false;\n\n    boolean result = a || b && c || !d;\n\n    System.out.println(result);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        boolean a = true;\n        boolean b = false;\n        boolean c = true;\n        boolean d = false;\n\n        boolean result = a || b && c || !d;\n\n        System.out.println(result);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 2\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    boolean a = true;\n    boolean b = false;\n    boolean c = true;\n    boolean d = false;\n\n    boolean result = !(a || b && c || !d) || (a && b || c);\n\n    System.out.println(result);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        boolean a = true;\n        boolean b = false;\n        boolean c = true;\n        boolean d = false;\n\n        boolean result = !(a || b && c || !d) || (a && b || c);\n\n        System.out.println(result);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 3\n\nSay you have two boolean variables, how could you use the operators we've covered to get the \"exclusive or\" of the two.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    // Change these two variables to test your solution\n    boolean hasIceCream = true;\n    boolean hasCookie = false;\n\n    boolean validChoice = < YOUR CODE HERE >;\n\n    System.out.println(validChoice);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // Change these two variables to test your solution\n        boolean hasIceCream = true;\n        boolean hasCookie = false;\n\n        boolean validChoice = < YOUR CODE HERE >;\n\n        System.out.println(validChoice);\n    }\n}\n```\n\n~ENDIF\n\nMake sure to test all the possibilities.\n\n| hasIceCream | hasCookie | validChoice |\n| ----------- | --------- | ----------- |\n| true        | true      | false       |\n| true        | false     | true        |\n| false       | true      | true        |\n| false       | false     | false       |\n", "number": [5, 5], "sub_items": [], "path": "boolean/challenges.md", "source_path": "boolean/challenges.md", "parent_names": ["Booleans"]}}], "path": "boolean.md", "source_path": "boolean.md", "parent_names": []}}, {"Chapter": {"name": "Integers", "content": "# Integers\n\n[An integer is any number in the set `{ ..., -2, -1, 0, 1, 2, ... }.`](https://www.khanacademy.org/math/cc-sixth-grade-math/cc-6th-expressions-and-variables/whole-numbers-integers/a/whole-numbers-integers)\n\n```java\nint x = 1;\nint y = 8;\nint z = -4;\n```\n", "number": [6], "sub_items": [{"Chapter": {"name": "Integer Literals", "content": "# Integer Literals\n\nIn order to write an integer in a program, you write an \"integer literal.\"\n\n```java\n789\n```\n\nWe call them this because the integer is literally written down in the program.\n\n```java\nint trueCrime = 789;\n```\n", "number": [6, 1], "sub_items": [], "path": "integers/integer_literals.md", "source_path": "integers/integer_literals.md", "parent_names": ["Integers"]}}, {"Chapter": {"name": "Addition", "content": "# Addition\n\nYou can add any two `int`s using the `+` operator.\n\n```java\nint x = 5;\n// y will be 6\nint y = x + 1;\n// z will be 11\nint z = x + y;\n\nSystem.out.println(x);\nSystem.out.println(y);\nSystem.out.println(z);\n```\n\nAdding a negative number does the same thing as subtraction.\n\n```java\nint x = 5;\n// y will be 1\nint y = x + -4;\n\nSystem.out.println(x);\nSystem.out.println(y);\n```\n", "number": [6, 2], "sub_items": [], "path": "integers/addition.md", "source_path": "integers/addition.md", "parent_names": ["Integers"]}}, {"Chapter": {"name": "Subtraction", "content": "# Subtraction\n\nYou can subtract any two `int`s using the `-` operator.\n\n```java\nint x = 5;\n// y will be 4\nint y = x - 1;\n// z will be 1\nint z = x - y;\n\nSystem.out.println(x);\nSystem.out.println(y);\nSystem.out.println(z);\n```\n\nSubtracting a negative number does the same thing as addition.\n\n```java\nint x = 5;\n// y will be 9\nint y = x - -4;\n\nSystem.out.println(x);\nSystem.out.println(y);\n```\n", "number": [6, 3], "sub_items": [], "path": "integers/subtraction.md", "source_path": "integers/subtraction.md", "parent_names": ["Integers"]}}, {"Chapter": {"name": "Multiplication", "content": "# Multiplication\n\nYou can multiply any two `int`s using the `*` operator.\n\n```java\n// x will be 15\nint x = 3 * 5;\n// y will be 75\nint y = x * 5;\n// z will be 1125\nint z = x * y;\n\nSystem.out.println(x);\nSystem.out.println(y);\nSystem.out.println(z);\n```\n", "number": [6, 4], "sub_items": [], "path": "integers/multiplication.md", "source_path": "integers/multiplication.md", "parent_names": ["Integers"]}}, {"Chapter": {"name": "Division", "content": "# Division\n\nYou can divide any two `int`s using the `/` operator.\n\n```java\nint x = 8;\n// y will be 4\nint y = x / 2;\n\nSystem.out.println(x);\nSystem.out.println(y);\n```\n\nDivision with integers gives results in only the [quotient](https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/the-quotient-remainder-theorem) of the result, not the remainder.\n\nSo `5 / 2` does not result in `2.5`, but instead just `2`.\n\n```java\n// 5 / 2 is not 2.5, but instead 2.\nint x = 5 / 2;\n// 13 / 3 is not 4.3333, but instead 4.\nint y = 13 / 3;\n\nSystem.out.println(x);\nSystem.out.println(y);\n```\n", "number": [6, 5], "sub_items": [], "path": "integers/division.md", "source_path": "integers/division.md", "parent_names": ["Integers"]}}, {"Chapter": {"name": "Remainder", "content": "# Remainder\n\nTo get the remainder of the division between two integers you can use the `%` operator.\nThis is called the \"modulo operator.\"\n\n```java\nint x = 5;\n// The remainder of 5 / 2 is 1\n// y will be 1\nint y = x % 2;\n// The remainder of 5 / 3 is 2\n// z will be 2\nint z = x % 3;\n\nSystem.out.println(x);\nSystem.out.println(y);\nSystem.out.println(z);\n```\n\nA common use for this is to make numbers \"go in a circle.\"\n\nFor instance, say you wanted to count from 0 up to 3 and then go back to 0.\n\n```java\nint value = 0;\nSystem.out.println(value);\n\n// the remainder of (0 + 1) divided by 3 is 1\n// value will be 1\nvalue = (value + 1) % 3;\nSystem.out.println(value);\n\n\n// the remainder of (1 + 1) divided by 3 is 2\n// value will be 2\nvalue = (value + 1) % 3;\nSystem.out.println(value);\n\n\n// the remainder of (2 + 1) divided by 3 is 0\n// value will again be 0!\nvalue = (value + 1) % 3;\nSystem.out.println(value);\n\n// the remainder of (0 + 1) divided by 3 is 1\n// value will be 1\nvalue = (value + 1) % 3;\nSystem.out.println(value);\n\n// and so on.\n```\n\nThe fact that all the reassignments of value look identical is something that will be useful in tandem\nwith loops.\n", "number": [6, 6], "sub_items": [], "path": "integers/remainder.md", "source_path": "integers/remainder.md", "parent_names": ["Integers"]}}, {"Chapter": {"name": "Equality", "content": "# Equality\n\nAny two `int`s can be inspected to see if their value is equal by using the `==` operator.\n\nUnlike the previous operators, which all take `int`s and produce `int`s as their result, `==` takes two `int`s\nand produces a `boolean` as its result.\n\n```java\n// 1 is never equal to 2\n// this will be false\nboolean universeBroken = 1 == 2;\nSystem.out.println(universeBroken);\n\nboolean loneliestNumber = 1;\nboolean otherLonelyNumber = 2;\n\n// this will be true\nboolean bothLonely = loneliestNumber == (otherLonelyNumber - 1);\nSystem.out.println(bothLonely);\n```\n\nIt is very important to remember that a single `=` does an assignment. Two equals signs `==` checks for equality.\n\nThe opposite check, whether things are not equal, can be done with `!=`.\n\n```java\n// 1 is never equal to 2\n// this will be true\nboolean universeOkay = 1 != 2;\nSystem.out.println(universeOkay);\n```\n", "number": [6, 7], "sub_items": [], "path": "integers/equality.md", "source_path": "integers/equality.md", "parent_names": ["Integers"]}}, {"Chapter": {"name": "Comparison", "content": "# Comparison\n\nIn addition to comparing for equality with `==` and `!=`, `int`s can be compared to see if one is bigger than another using\n`>`, `<`, `>=`, and `<=`.\n\n`>` will evaluate to true if the number on the left is greater than the one on the right.\n\n```java\nboolean willBeTrue = 5 > 2;\nboolean willBeFalse = 2 > 5;\n```\n\n`<` will evaluate to true if the number on the right is greater than the one on the left.\n\n```java\nboolean willBeFalse = 5 < 2;\nboolean willBeTrue = 2 < 5;\n```\n\nIf you went to public school like I did, you should be used to imagining that the `>` was the jaw of a shark.\nWhatever direction the Jaws are facing, thats the one that would need to be bigger for the statement to be true.[^sharks]\n\n```java\n// true if the shark is facing the bigger number\n// false otherwise.\nboolean result = 9 \ud83e\udd88 5;\n```\n\n`>=` behaves the same as `>` except `>=` will evaluate to `true` if the numbers are identical, `>` will not.\n\n```java\nboolean willBeTrue = 5 >= 5;\nboolean willBeFalse = 5 > 5;\n```\n\n`<=` has the same relationship to `<` as `>=` does to `>`.\n\n```java\nboolean willBeTrue = 5 <= 5;\nboolean willBeFalse = 5 < 5;\n```\n\n[^sharks]: Shark attacks are far more rare than people think they are. You are not a seal.\n", "number": [6, 8], "sub_items": [], "path": "integers/comparison.md", "source_path": "integers/comparison.md", "parent_names": ["Integers"]}}, {"Chapter": {"name": "Chained Comparisons", "content": "# Chained Comparisons\n\nWhen writing an expression in math to say something along the lines of\n\"`x` is greater than zero and less than 5,\" it is natural to put that `x`\nin the middle of both operators like so.\n\n```text\n0 < x < 5\n```\n\nThis does not work in Java. In order to \"chain\" comparisons like this, you should combine\nthe results of comparisons using the `&&` operator.\n\n```java\nboolean xInRange = 0 < x && x < 5;\n```\n", "number": [6, 9], "sub_items": [], "path": "integers/chained_comparisons.md", "source_path": "integers/chained_comparisons.md", "parent_names": ["Integers"]}}, {"Chapter": {"name": "Operator Precedence", "content": "# Operator Precedance\n\nJust like boolean operators, `+`, `-`, `*`, `/`, and `%` have a defined precedence order.\n\nThe order of operations is the same as mathematics. Multiplication and division happen before\naddition and subtraction, with the modulo operator being a sort of \"funky division.\"\nParentheses can be used to control this order.\n\nNone of this should be a surprise if you learned [PEMDAS](https://www.khanacademy.org/math/cc-seventh-grade-math/cc-7th-negative-numbers-multiply-and-divide/cc-7th-order-of-operations/v/introduction-to-order-of-operations) in school.\n\n```java\n// Following the order of operations:\n// 2 * 3 + 3 * 9 / 2 - 2\n\n// 2 * 3 happens first\n// 6 + 3 * 9 / 2 - 2\n\n// 3 * 9 happens next\n// 6 + 27 / 2 - 2\n\n// 27 / 2 happens next\n// because of integer division, that gives 13\n// 6 + 13 - 2\n\n// 6 + 13 comes next\n// 19 - 2\n\n// and the final result is 17;\nint result = 2 * 3 + 3 * 9 / 2 - 2;\nSystem.out.println(result);\n```\n\nThe `==`, `!=`, `>`, `<`, `>=`, and `<=` operators play a part here too[^theyalldo]. They all have a lower precedence order than all the math operators, so you can\nput them in the middle of any two math expressions.\n\n```java\n// The == check happens last.\nboolean areThingsSame = 3 * (4 - 1 + 3) * 4 == 5 * 3 + 1 * 3 * 9;\n```\n\n[^theyalldo]: Every operator in the language has a defined order of operations with respect to all of the others. I am just showing them to you as they become relevant.\n", "number": [6, 10], "sub_items": [], "path": "integers/operator_precedence.md", "source_path": "integers/operator_precedence.md", "parent_names": ["Integers"]}}, {"Chapter": {"name": "Reassignment", "content": "# Reassignment\n\nWhen the value of a variable is reassigned, the value stored in the variable\nbefore the reassignment can be used to compute the new value.\n\nThis is true for all data types, but it is easiest to demonstrate with numbers.\n\n```java\nint x = 1;\nSystem.out.println(x);\n\n// x starts as 1, 1 + 1 is 2.\n// 2 is the new value of x.\nx = x + 1;\nSystem.out.println(x);\n\n// x is now 2, 2 * 2 * 3 is 12\n// 12 is the new value of x.\nx = x * x * 3;\nSystem.out.println(x);\n```\n\nThis property was used in the previous example for the `%` operator, but I think it worth calling attention to even if it is \"intuitive\".\n", "number": [6, 11], "sub_items": [], "path": "integers/reassignment.md", "source_path": "integers/reassignment.md", "parent_names": ["Integers"]}}, {"Chapter": {"name": "Shorthands for Reassignment", "content": "# Shorthands for Reassignment\n\nA very common thing to do is to take the current value of a variable, perform some simple operation like addition on it, and reassign the newly\ncomputed value back into the variable.\n\n```java\nint x = 2;\nSystem.out.println(x);\n\nx = x * 5 // 10\nSystem.out.println(x);\n```\n\nAs such, there is a dedicated way to do just that.\n\n```java\nint x = 1;\n\n// This is the same as\n// x = x + 2;\nx += 2;\n\n// This is the same as\n// x = x * 4\nx *= 4;\n\n// This is the same as\n// x = x - (x * 5)\nx -= (x * 5)\n\n// This is the same as\n// x = x / 6\nx /= 6;\n\n// This is the same as\n// x = x % 3\nx %= 3;\n\n// Pop quiz!\nSystem.out.println(x);\n```\n\nOf note is that adding or subtracting exactly 1 is common enough that it\nhas its own special shorthand.\n\n```java\nint x = 0;\nSystem.out.println(x);\n\n// Same as\n// x = x + 1;\n// x += 1;\nx++;\nSystem.out.println(x);\n\n// Same as\n// x = x - 1;\n// x -= 1;\nx--;\nSystem.out.println(x);\n```\n", "number": [6, 12], "sub_items": [], "path": "integers/shorthands_for_reassignment.md", "source_path": "integers/shorthands_for_reassignment.md", "parent_names": ["Integers"]}}, {"Chapter": {"name": "Limits", "content": "# Limits\n\nUnlike in math, where numbers can be arbitrarily big or small, a Java `int`\nis \"fixed width.\"\n\nSay you had a piece of paper that was only big enough to write two numbers on.\n\nThe only numbers you could write in a [base ten system](https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra/algebra-alternate-number-bases/v/number-systems-introduction) would be those from 0 to 99. You could not write 100 or anything larger.\n\nA Java `int` is similar except instead of only being able to write 0 to 99 on a piece of paper, a variable that has\nthe type `int` can represent numbers from -2<sup>31</sup> to 2<sup>31</sup> - 1.\n\nIf you try to directly write out a number that is outside of that range, Java will not let you.\n\n```java\n// This will not run\nint tooBig = 999999999999;\n```\n\nIf you do math that should produce a larger number than is representable, the value will \"loop around.\"\n\n```java\n// This is the value of 2^31 - 1\nint atLimit = 2147483647;\n// The value will \"loop around\" to -2^31\nint beyondLimit = atLimit + 1;\n// This will output -2147483648\nSystem.out.println(beyondLimit);\n```\n\nThere are other types which can represent a larger range of integers, as well as types\nwhich do not have any limits, but for now `int` is the only one you will need.\n", "number": [6, 13], "sub_items": [], "path": "integers/limits.md", "source_path": "integers/limits.md", "parent_names": ["Integers"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nRemember the rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\n## Challenge 1\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    int x = 5;\n    int y = 8;\n    System.out.println(x + y);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int x = 5;\n        int y = 8;\n        System.out.println(x + y);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 2\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    int x = 5;\n    x--;\n    x--;\n    x = x + x;\n    System.out.println(x);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int x = 5;\n        x--;\n        x--;\n        x = x + x;\n        System.out.println(x);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 3\n\nMake it so that this program correctly determines if the numbers are even or not.\n\nAssume that the values of `x`, `y`, and `z` could be changed. Don't just write out\nliterally `true` and `false` for their current values.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    int x = 5;\n    int y = 4;\n    int z = 98;\n\n    boolean xIsEven = < CODE HERE >;\n    System.out.println(xIsEven);\n\n    boolean yIsEven = < CODE HERE >;\n    System.out.println(yIsEven);\n\n    boolean zIsEven = < CODE HERE >;\n    System.out.println(zIsEven);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int x = 5;\n        int y = 4;\n        int z = 98;\n\n        boolean xIsEven = < CODE HERE >;\n        System.out.println(xIsEven);\n\n        boolean yIsEven = < CODE HERE >;\n        System.out.println(yIsEven);\n\n        boolean zIsEven = < CODE HERE >;\n        System.out.println(zIsEven);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 4\n\nTry dividing a number by zero. What happens?\n\nWrite down your guess and then try running the program below to see.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    System.out.println(5 / 0);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(5 / 0);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 5\n\nWhat can you write in the spot marked that will make the program output 2?\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    int x = 5;\n    int y = <CODE HERE>;\n    System.out.println(x + y);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int x = 5;\n        int y = <CODE HERE>;\n        System.out.println(x + y);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 6\n\nWhat is the output of this code.[^fbarticle]\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    System.out.println(\n        6 / 2 * (1 + 2)\n    );\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\n            6 / 2 * (1 + 2)\n        );\n    }\n}\n```\n\n~ENDIF\n\n[^fbarticle]: [Now get in a fight with your relatives about it](https://slate.com/technology/2013/03/facebook-math-problem-why-pemdas-doesnt-always-give-a-clear-answer.html)\n", "number": [6, 14], "sub_items": [], "path": "integers/challenges.md", "source_path": "integers/challenges.md", "parent_names": ["Integers"]}}], "path": "integers.md", "source_path": "integers.md", "parent_names": []}}, {"Chapter": {"name": "Floating Point Numbers", "content": "# Floating Point Numbers\n\nFloating point numbers are used to represent numbers\nwhich cannot be stored as Integers like `2.5` or `3.14`.\n\n```java\ndouble x = 1.5;\ndouble y = 8.0;\ndouble z = -3.14;\n```\n\nThe type you will use to store a floating point number is `double`.\n`double` stands for \"double precision floating point.\"\n", "number": [7], "sub_items": [{"Chapter": {"name": "Floating Point Literals", "content": "# Floating Point Literals\n\nIn order to write a floating point number in a program, you use a \"floating-point literal.\"\n\n```java\n1.5\n```\n\nAny number written with a decimal point is a floating point literal.\n\n```java\ndouble pi = 3.14;\n```\n\nThis includes numbers where a decimal point is written, but there is no fractional part\nto the number.\n\n```java\n5.0\n```\n\nYou cannot directly give a value to an integer variable using a floating point literal, even if there is no fractional part to the number.\n\n```java\n// this will not work\nint x = 5.0;\n```\n\nThe reverse is possible though. You can give a value to a variable that stores\na floating point number using an integer literal.\n\n```java\ndouble x = 5;\n```\n", "number": [7, 1], "sub_items": [], "path": "floating_point_numbers/floating_point_literals.md", "source_path": "floating_point_numbers/floating_point_literals.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "Accuracy", "content": "# Accuracy\n\nFloating Point numbers are not an exact representation of numbers.\n\nThe reasons for this are twofold.\n\n1. It is much more efficient for a computer to work with data that is a \"fixed size\". You can't cram all the infinite possible\n   numbers into 32, 64, or any fixed number of bits.\n2. For most systems, the inaccuracy is okay. When it is not, there are ways to do \"real math\" that we will cover much later.\n\n<!-- TODO: Cover BigInteger and BigDecimal and link back here. -->\n<!-- TODO: Write an actual explanation and don't defer to computerphile. -->\n\nFor an explanation of the mechanics, I'll defer to this old Computerphile video.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/PZRI1IfStY0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n", "number": [7, 2], "sub_items": [], "path": "floating_point_numbers/accuracy.md", "source_path": "floating_point_numbers/accuracy.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "Addition", "content": "# Addition\n\nYou can add any two `double`s using the `+` operator.\n\n```java\ndouble x = 5.1;\n// y will be 14.2\ndouble y = x + 9.1;\n```\n\nBecause of the previously mentioned inaccuracy, the results of additions might not always be what you expect.\n\n```java\n// z will be 19.299999999999997\ndouble z = x + y;\n```\n\nYou can add any `int` to a `double` and the result of any such addition will also be a `double`.\n\n```java\nint x = 5;\ndouble y = 4.4;\n// z will be 9.4\ndouble z = x + y;\n\nSystem.out.println(x);\nSystem.out.println(y);\nSystem.out.println(z);\n```\n\nEven if the result of such an expression will not have any fractional parts, you cannot directly assign it to an int.\n\n```java\nint x = 5;\ndouble y = 4;\n// even though z would be 9, which can be stored in an int\n// this will not work. The result of the expression is a double.\nint z = x + y;\n\nSystem.out.println(x);\nSystem.out.println(y);\nSystem.out.println(z);\n```\n", "number": [7, 3], "sub_items": [], "path": "floating_point_numbers/addition.md", "source_path": "floating_point_numbers/addition.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "Subtraction", "content": "# Subtraction\n\nYou can subtract any two `double`s using the `-` operator.\n\n```java\ndouble x = 5.1;\n// y will be 4.1\ndouble y = x - 9.2;\n\nSystem.out.println(x);\nSystem.out.println(y);\n```\n\nBecause of the previously mentioned inaccuracy, the results of subtractions might not always be what you expect.\n\n```java\n// z will be -4.199999999999999\ndouble z = y - 0.1;\n\nSystem.out.println(z);\n```\n\nYou can subtract any `int` to or from a `double` and the result of any such subtraction will also be a `double`.\n\n```java\nint x = 5;\ndouble y = 4.5;\n// z will be 0.5\ndouble z = x - y;\n\nSystem.out.println(x);\nSystem.out.println(y);\nSystem.out.println(z);\n```\n\nEven if the result of such an expression will not have any fractional parts, you cannot directly assign it to an `int`.\n\n```java\nint x = 5;\ndouble y = 4;\n// even though z would be 1, which can be stored in an int\n// this will not work. The result of the expression is a double.\nint z = x - y;\n```\n", "number": [7, 4], "sub_items": [], "path": "floating_point_numbers/subtraction.md", "source_path": "floating_point_numbers/subtraction.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "Multiplication", "content": "# Multiplication\n\nYou can multiply any two `double`s using the `*` operator.\n\n```java\ndouble x = 3;\n// y will be 27\ndouble y = x * 9;\n// z will be 13.5\ndouble z = y * 0.5;\n\nSystem.out.println(x);\nSystem.out.println(y);\nSystem.out.println(z);\n```\n\nJust like with addition and subtraction, it is fine to use both integers and integer literals when doing\nmultiplication on doubles. So long as any number being used is a `double` the overall result will be a double.\n\n```java\n// a will be 3\ndouble a = 1.5 * 2;\n```\n", "number": [7, 5], "sub_items": [], "path": "floating_point_numbers/multiplication.md", "source_path": "floating_point_numbers/multiplication.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "Division", "content": "# Division\n\nYou can divide any two `double`s using the `/` operator.\n\n```java\ndouble x = 8;\n// y will be 4.0\ndouble y = x / 2;\n// z will be 1.3333333333333333\ndouble z = y / 3;\n\nSystem.out.println(x);\nSystem.out.println(y);\nSystem.out.println(z);\n```\n\nUnlike with integer division, floating point division will include the remainder in the result.[^caveat]\n\n[^caveat]: With the caveat that the result is now potentially inaccurate.\n", "number": [7, 6], "sub_items": [], "path": "floating_point_numbers/division.md", "source_path": "floating_point_numbers/division.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "Equality", "content": "# Equality\n\nJust like `int`s, `double`s can be inspected to see if they are equal to one another using `==`.\n\n```java\ndouble numberOfToes = 10.0;\ndouble numberOfFingers = 10.0;\n\nboolean humanGenerated = numberOfToes == numberOfFingers;\n```\n\nBecause of floating point inaccuracy, this might not always give you the result you expect though.\n\n```java\ndouble x = 0.1;\ndouble y = 0.2;\n// z will be 0.30000000000000004\ndouble z = x + y;\n\n// this will be false.\nboolean doesWhatYouExpect = z == 0.3;\n```\n\nA `double` can also be compared to an `int` and, if they represent the same value, they will be reported as equal.\n\n```java\nint x = 5;\ndouble y = 5.0;\n\n// will be true\nboolean fiveIsFive = x == y;\n```\n", "number": [7, 7], "sub_items": [], "path": "floating_point_numbers/equality.md", "source_path": "floating_point_numbers/equality.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "Comparison", "content": "# Comparison\n\nIn addition to comparing for equality with `==` and `!=`, `doubles`s can be compared to see if one is bigger than another using\n`>`, `<`, `>=`, and `<=`.\n\nThis works the same as it does with `int`s.\n\n```java\ndouble x = 1.5;\ndouble y = 0.2;\n\n// true\nSystem.out.println(x > y);\n// false\nSystem.out.println(x < y);\n```\n", "number": [7, 8], "sub_items": [], "path": "floating_point_numbers/comparison.md", "source_path": "floating_point_numbers/comparison.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "Shorthands for Reassignment", "content": "# Shorthands for Reassignment\n\nAll the same shorthands for reassignment work with `double`s the same as they do with `int`s.\n\n```java\ndouble x = 0.5;\n// 0.5\nSystem.out.println(x);\n\nx += 3;\n// 3.5\nSystem.out.println(x);\n\nx -= 1;\n// 2.5\nSystem.out.println(x);\n\nx++;\n// 3.5\nSystem.out.println(x);\n\nx--;\n// 2.5\nSystem.out.println(x);\n\nx *= 5;\n// 12.5\nSystem.out.println(x);\n\nx /= 2;\n// 6.25\nSystem.out.println(x);\n```\n", "number": [7, 9], "sub_items": [], "path": "floating_point_numbers/shorthands_for_reassignment.md", "source_path": "floating_point_numbers/shorthands_for_reassignment.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "NaN", "content": "# NaN\n\nThere is a special floating point number called `NaN`, which stands for \"Not a Number.\"\n\nYou generally only encounter `NaN` as the result of doing something silly like dividing zero by zero.\n\n```java\ndouble nan = 0.0 / 0.0;\n```\n\n`NaN` is not equal to itself.\n\n```java\n// will be false\nboolean equalToItself = nan == nan;\n\nSystem.out.println(equalToItself);\n```\n\n`NaN` is not greater than itself.\n\n```java\n// will be false\nboolean greaterThanItself = nan > nan;\n\nSystem.out.println(greaterThanItself);\n```\n\n`NaN` is not less than itself.\n\n```java\n// will be false\nboolean lessThanItself = nan < nan;\n\nSystem.out.println(lessThanItself);\n```\n\n`NaN` is not greater than, less than, or equal to any number.\n\n```java\n// will all be false\nSystem.out.println(nan < 5);\nSystem.out.println(nan > 5);\nSystem.out.println(nan == 5);\n```\n\nNone of this is usually useful, but it is fun to know about.\n", "number": [7, 10], "sub_items": [], "path": "floating_point_numbers/nan.md", "source_path": "floating_point_numbers/nan.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "Positive and Negative Infinity", "content": "# Positive and Negative Infinity\n\nIn addition to the wackyness of `NaN`, floating point numbers can also represent both positive\nand negative infinity.\n\nYou can get positive infinity by dividing any positive number by zero.\n\n```java\ndouble positiveInfinity = 1.0 / 0.0;\n```\n\nYou can get negative infinity by dividing any negative number by zero.\n\n```java\ndouble negativeInfinity = -1.0 / 0.0;\n```\n\nAs you might expect, positive infinity is greater than any number and negative infinity is less than any number.\n\n```java\n// true\nSystem.out.println(positiveInfinity > 99999999);\n\n// true\nSystem.out.println(negativeInfinity < -99999999);\n```\n\nExcept for `NaN`, of course.\n\n```java\ndouble nan = 0.0 / 0.0;\n\n// false\nSystem.out.println(positiveInfinity > nan);\n\n// false\nSystem.out.println(negativeInfinity < nan);\n```\n", "number": [7, 11], "sub_items": [], "path": "floating_point_numbers/positive_and_negative_infinity.md", "source_path": "floating_point_numbers/positive_and_negative_infinity.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "Square Root", "content": "# Square Root\n\nA relatively common operation to want to perform on floating point numbers\nis to find their square root.\n\nYou can do this with `Math.sqrt`.\n\n```java\ndouble x = 4;\ndouble y = Math.sqrt(x);\n\n// This will output 2\nSystem.out.println(y);\n```\n\nYou need to write `Math.sqrt` and then inside of parentheses the expression whose value you want to take the square root of..\n\n```java\ndouble x = 5;\ndouble y = 13;\ndouble z = Math.sqrt(9 * x + y);\n\n// This will output 7.615773105863909\nSystem.out.println(z);\n```\n\nIf you try to take the square root of a negative number, the result will be `NaN`.\n\n```java\n// will output NaN\nSystem.out.println(Math.sqrt(-5.2));\n```\n", "number": [7, 12], "sub_items": [], "path": "floating_point_numbers/square_root.md", "source_path": "floating_point_numbers/square_root.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "Conversion to Integers", "content": "# Conversion to Integers\n\nNormally, a `double` value cannot be assigned to an `int`.\n\n```java\ndouble x = 5.0;\n// will not work\nint y = x;\n```\n\nThe reason for this is that there are numbers like `2.5`, the infinities, and `NaN` which do not have an\nobvious way to be represented as an integer.\n\nThere are also numbers which a `double` can represent like `4207483647.0` and `-9999999999.0`\nwhich happen to be too big or too small to fit into the limits of an `int` even though they\ndo have an obvious \"integer representation.\"\n\nAs such, to make an `int` out of a `double` you need to accept that it is a \"narrowing conversion.\"\nThe number you put in won't neccesarily be the number you get out.\n\nTo perform such a narrowing conversion, you need to put `(int)` before a literal or expression that\nevaluates to a `double`.\n\n```java\ndouble x = 5.0;\n// will be 5\nint y = (int) x;\n\nSystem.out.println(y);\n```\n\nAny decimal part of the number will be dropped. So numbers like `2.1`, `2.5`, and `2.9` will all be converted into\nsimply `2`.\n\n```java\nint x = (int) 2.1;\nint y = (int) 2.5;\nint z = (int) 2.9;\n\nSystem.out.println(x);\nSystem.out.println(y);\nSystem.out.println(z);\n```\n\nAny number that is too big to store in an `int` will be converted to the biggest possible `int`, 2<sup>31</sup> - 1.\n\n```java\n// 2147483647\nSystem.out.println((int) 4207483647.0);\n\ndouble positiveInfinity = 5.0 / 0.0;\n// 2147483647\nSystem.out.println((int) positiveInfinity);\n```\n\nAny number that is too small to store in an `int` will be converted to the smallest possible `int`, -2<sup>31</sup>.\n\n```java\n// -2147483648\nSystem.out.println((int) -9999999999.0);\n\ndouble negativeInfinity = -5.0 / 0.0;\n// -2147483648\nSystem.out.println((int) negativeInfinity);\n```\n\nAnd `NaN` will be converted to zero.\n\n```java\ndouble nan = 0.0 / 0.0;\nSystem.out.println((int) nan);\n```\n\nWhen you use `(int)` to convert, we call that a \"cast[^cast] expression\". The `(int)` is a \"cast operator.\" It even has\na place in the operator precedence order just like `+`, `-`, `==`, etc.\n\nThe main difference is that instead of appearing between two expressions like the `+` in `2 + 5`, it appears to the left of a single expression.\n\n[^cast]: https://english.stackexchange.com/questions/220001/etymology-of-type-cast\n", "number": [7, 13], "sub_items": [], "path": "floating_point_numbers/conversion_to_integers.md", "source_path": "floating_point_numbers/conversion_to_integers.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "Conversion from Integers", "content": "# Conversion from Integers\n\nTo convert from an `int` to a `double`, you don't need to do any special work. All `int`s are\nrepresentable as `double`s so it is a \"widening conversion\" and will be handled automatically\nby Java when performing an assignment.\n\n```java\nint x = 5;\ndouble y = x;\n\nSystem.out.println(x);\nSystem.out.println(y);\n```\n\nThis is not true in an expression. Even if the result of a computation between `int`s is being assigned to\na `double`, the computation will still be performed using the same rules `int`s usually follow.\n\n```java\nint x = 7;\nint y = 2;\n// integer division of 7 and 2 gives 3.\ndouble z = x / y;\n\nSystem.out.println(z);\n```\n\nTo perform math on an `int` and have that `int` behave as if it were a `double`, you need to convert said `int` into\na `double` using a cast expression and the `(double)` cast operator.\n\n```java\nint x = 7;\nint y = 2;\n// This converts x into a double before performing the division\n// so the result will be 3.5.\ndouble z = (double) x / y;\n\nSystem.out.println(z);\n```\n", "number": [7, 14], "sub_items": [], "path": "floating_point_numbers/conversion_from_integers.md", "source_path": "floating_point_numbers/conversion_from_integers.md", "parent_names": ["Floating Point Numbers"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nRemember the rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\n## Challenge 1\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    double x = 5.1;\n    double y = 2.4;\n    System.out.println(x + y);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        double x = 5.1;\n        double y = 2.4;\n        System.out.println(x + y);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 2\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    double x = 5.1;\n    double y = 2.1;\n    System.out.println(x + y);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        double x = 5.1;\n        double y = 2.1;\n        System.out.println(x + y);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 3\n\nWhat will this program output when run? Write down your guess and then try running it.\n\nHow can you make it give the \"right\" answer?\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    double x = 5 / 2;\n    System.out.println(x);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        double x = 5 / 2;\n        System.out.println(x);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 4\n\nThese two expressions give different results. Why is that, and what results do they give?\n\n```java\ndouble resultOne = (int) 5.0 / 2 + 5.0 / 2;\ndouble resultTwo = (int) (5.0 / 2 + 5.0 / 2);\n\nSystem.out.println(resultOne);\nSystem.out.println(resultTwo);\n```\n\n## Challenge 5\n\nThe following is a quadratic equation.\n\n\\\\[ 2x^2 + 8x + 3 = 0 \\\\]\n\nTo find the solutions of any quadratic equation you can use the following formula.\n\n\\\\[ x = \\frac{-b \\pm \\sqrt{b^2 - 4ac} }{2a} \\\\]\n\nWhere \\\\(a\\\\), \\\\(b\\\\), and \\\\(c\\\\) are the prefixes of each term in the following equation.\n\n\\\\[ ax^2 + bx + c = 0 \\\\]\n\nWrite some code that finds both solutions to any quadratic equation defined by some variables\n`a`, `b`, and `c`. If the equation has imaginary solutions, you are allowed to just output `NaN`.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    // For this one in particular, you should output\n    // -3.5811388300842 and -0.41886116991581\n    // but your code should work with these three numbers changed to\n    // represent any given quadratic equation.\n    double a = 2;\n    double b = 8;\n    double c = 3;\n\n    double resultOne = ???;\n    double resultTwo = ???;\n\n    System.out.println(resultOne);\n    System.out.println(resultTwo);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // For this one in particular, you should output\n        // -3.5811388300842 and -0.41886116991581\n        // but your code should work with these three numbers changed to\n        // represent any given quadratic equation.\n        double a = 2;\n        double b = 8;\n        double c = 3;\n\n        double resultOne = ???;\n        double resultTwo = ???;\n\n        System.out.println(resultOne);\n        System.out.println(resultTwo);\n    }\n}\n```\n\n~ENDIF\n", "number": [7, 15], "sub_items": [], "path": "floating_point_numbers/challenges.md", "source_path": "floating_point_numbers/challenges.md", "parent_names": ["Floating Point Numbers"]}}], "path": "floating_point_numbers.md", "source_path": "floating_point_numbers.md", "parent_names": []}}, {"Chapter": {"name": "Characters", "content": "# Characters\n\nA character, represented by the data type `char`, is a single\nletter or symbol.\n\n```java\nchar letter = 'a';\n```\n\nI choose to pronounce it like the \"char\" in \"Charmander.\"\n", "number": [8], "sub_items": [{"Chapter": {"name": "Character Literals", "content": "# Character Literals\n\nIn order to write a character in a program, you write that one character surrounded\nby single quotes.\n\n```java\n'a'\n```\n\nThis is called a \"character literal.\" It has the same relationship to `char` that an integer literal like 123 has to `int`.\n\n```java\n// Same as this \"integer literal\" is used to write a number\nint sesameStreet = 123;\n// A \"character literal\" is used to write text\nchar thisEpisodeIsBroughtToYouBy = 'c';\n```\n", "number": [8, 1], "sub_items": [], "path": "characters/character_literals.md", "source_path": "characters/character_literals.md", "parent_names": ["Characters"]}}, {"Chapter": {"name": "Common Escape Sequences", "content": "# Common Escape Sequences\n\nWhile most characters can be written directly into a program, as is the\ncase for `a`, `b`, or `t`, there are some which cannot.\n\nFor these, you need to use what is called an \"escape sequence.\"\n\nThe most common escape sequence you will use will be the one for a \"new line.\"\nWhich is a backslash followed by an `n`.\n\n```java\nchar newline = '\\n';\n```\n\nBecause a backslash is used for this special syntax, to put a backslash into a character literal\nyou need to escape it with a backslash of its own.\n\n```java\nchar backslash = '\\\\';\n```\n\nAnd because single quotes are used to mark the start and end of a character literal, they need to be escaped\nas well.\n\n```java\nchar singleQuote = '\\'';\n```\n", "number": [8, 2], "sub_items": [], "path": "characters/common_escape_sequences.md", "source_path": "characters/common_escape_sequences.md", "parent_names": ["Characters"]}}, {"Chapter": {"name": "Conversion to Integers", "content": "# Conversion to Integers\n\nAll `char`s have a matching numeric value. `'a'` is `97`, `'b'` is `98`,\n`'&'` is `38`, and so on.\n\nSame as assigning an `int` to a `double`, you can perform a widening conversion\nby attempting to assign a `char` to an `int`.\n\n```java\nint valueOfA = 'a';\n\nSystem.out.println(valueOfA);\n```\n\n`char`s will be automatically converted to `int`s when used with mathmatical operators like `+`, `-`, `>`, `<`, etc.\n\n```java\nchar gee = 'g';\n\n// all the letters from a to z have consecutive numeric values.\nboolean isLetter = gee >= 'a' && gee <= 'z';\n\nSystem.out.println(isLetter);\n```\n\nThis can be useful if you are stranded on Mars[^onmars] or\nif you want to see if a character is in some range.\n\n[^onmars]: https://www.youtube.com/watch?v=k-GH3mbvUro\n", "number": [8, 3], "sub_items": [], "path": "characters/conversion_to_integers.md", "source_path": "characters/conversion_to_integers.md", "parent_names": ["Characters"]}}, {"Chapter": {"name": "Conversion from Integers", "content": "# Conversion from Integers\n\nAn `int` can represent more values than a `char`, so conversion from `int` to\n`char` requires the use of the cast operator `(char)`.\n\n```java\nint x = 120;\n\nchar xAsChar = (char) x;\n\nSystem.out.println(xAsChar);\n```\n\nThis conversion is narrowing, so information might be lost if the `int` value is too big or too small to fit into a `char`.\n\nThe initial value of a `char` can also be given by an integer literal if the integer literal represents a small enough letter.\n\n```java\nchar z = 122;\n\nSystem.out.println(z);\n```\n", "number": [8, 4], "sub_items": [], "path": "characters/conversion_from_integers.md", "source_path": "characters/conversion_from_integers.md", "parent_names": ["Characters"]}}, {"Chapter": {"name": "Unicode", "content": "# Unicode\n\nMost letters and symbols that are common in the English speaking world fit into\na single `char`, so pretending that a `char` is always \"a single\nletter or symbol\" is generally a good enough mental model.\n\nWhere this falls apart is with things like emoji (\ud83d\udc68\u200d\ud83c\udf73) which are generally considered to be one symbol, but\ncannot be represented in a single `char`.\n\n```java\nchar chef = '\ud83d\udc68\u200d\ud83c\udf73';\n```\n\n`char`s are actually \"utf-16 code units\". Many symbols require multiple \"code units\" to represent.\n\nFor a full explanation, refer to this old Computerphile video.\n\nIt describes \"utf-8\", which is 8 bits per \"code unit.\" Java's `char`\nuses 16 bits, but that is the only difference.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/MijmeoH9LT4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n", "number": [8, 5], "sub_items": [], "path": "characters/unicode.md", "source_path": "characters/unicode.md", "parent_names": ["Characters"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nRemember the rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\n## Challenge 1\n\nA lot of math problems ask you to find \\\\( x^2 \\\\). What is the value of the character `x` squared?\n\nTry to work it out on paper before running the program below.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    char x = 'x';\n\n    System.out.println(x * x);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        char x = 'x';\n\n        System.out.println(x * x);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 2\n\nAlter the program below so that it will output `true` if the character declared at the top is a letter.\n\nMake use of the fact that the numeric values for `a` - `z` and `A` - `Z` are contiguous.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    char c = 'a';\n\n    boolean isLetter = ???;\n\n    System.out.println(isLetter);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        char c = 'a';\n\n        boolean isLetter = ???;\n\n        System.out.println(isLetter);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 3\n\nHow many UTF-16 code units does it take to represent this emoji? `\ud83d\udc68\u200d\ud83c\udf73`.\n", "number": [8, 6], "sub_items": [], "path": "characters/challenges.md", "source_path": "characters/challenges.md", "parent_names": ["Characters"]}}], "path": "characters.md", "source_path": "characters.md", "parent_names": []}}, {"Chapter": {"name": "Strings", "content": "# Strings\n\nThe `String` data type is used to represent text.\n\n```java\nString shortStory = \"Everyone lived happily ever after, the end.\"\n```\n\nThe word \"string\" comes from the fact that text is just individual characters \"strung together\".\n\nAs a concrete example `j`, `o`, and `e` can be \"strung together\" into the \"string\"\n`joe`.\n", "number": [9], "sub_items": [{"Chapter": {"name": "String Literals", "content": "# String Literals\n\nIn order to write text in a program, you surround it with\ndouble quotes.\n\n```java\n\"Hello, World\"\n```\n\nThis is called a \"string literal.\" It has the same relationship to `String`\nthat an integer literal like `123` has to `int`.\n\n```java\n// Same as this \"integer literal\" is used to write a number\nint abc = 123;\n// A \"string literal\" is used to write text\nString name = \"penelope\";\n```\n", "number": [9, 1], "sub_items": [], "path": "strings/string_literals.md", "source_path": "strings/string_literals.md", "parent_names": ["Strings"]}}, {"Chapter": {"name": "Common Escape Sequences", "content": "# Common Escape Sequences\n\nInside of a string literal, there are some characters that cannot be written normally.\n\nAn easy example is double quotes. You can't write double quotes in the middle of\na string literal because Java will think the extra quote is the end of the `String`.\n\n```java\nString title = \"The \"Honorable\" Judge Judy\";\n```\n\nIn order to make it work, the `\"`s need to be \"escaped\" with a backslash.\n\n```java\nString title = \"The \\\"Honorable\\\" Judge Judy\";\n```\n\nSince the backslash is used to escape characters, it too needs to escaped\nin order to have it be in a `String`. So to encode `\u00af\\_(\u30c4)_/\u00af` into a String\nyou need to escape the first backslash.\n\n```java\n// The first backslash needs to be escaped. \u00af\\_(\u30c4)_/\u00af\nString shruggie = \"\u00af\\\\_(\u30c4)_/\u00af\";\n```\n\nAnd much the same as with `char`, you need to use `\\n` to write in a newline.\n\n```java\nString letter = \"To Whom It May Concern,\\n\\nI am writing this letter to complain.\";\n```\n", "number": [9, 2], "sub_items": [], "path": "strings/common_escape_sequences.md", "source_path": "strings/common_escape_sequences.md", "parent_names": ["Strings"]}}, {"Chapter": {"name": "The Empty String", "content": "# The Empty String\n\nThere is a special `String` which contains no characters at all.\n\n```java\n// There is nothing to say.\nString conversationWithDog = \"\";\n```\n\nYou write it just like any other string, just with nothing between the double quotes.\n\n```java\n\"\"\n```\n\nIt is different from a `String` that just contains spaces because to Java those \"space characters\"\nare just as much real characters as `a`, `b`, or `c`.\n\n```java\n// There is noteworthy silence.\nString conversationWithInlaws = \" \";\n```\n\nThis is one of those things that feels totally useless, but comes in handy pretty often.\n\n- Say you are writing a message to send to your friend. The messenger\n  app can represent the state of the input box before you type anything with\n  an empty `String`.\n- If you want to digitally record responses to legal paperwork, you might choose\n  to represent skipped fields as empty `String`s.\n- Video Games where characters have assigned names can assign an empty `String`\n  as the name of otherwise \"unnamed\" characters.\n- etc.\n", "number": [9, 3], "sub_items": [], "path": "strings/empty_string.md", "source_path": "strings/empty_string.md", "parent_names": ["Strings"]}}, {"Chapter": {"name": "Multiline String Literals", "content": "# Multiline Strings\n\nIf the text you want to store in a `String` has multiple lines, you can use\nthree quotation marks to represent it in code.\n\n```java\nString poem = \"\"\"\n    I met a traveller from an antique land,\n    Who said\u2014\u201cTwo vast and trunkless legs of stone\n    Stand in the desert. . . . Near them, on the sand,\n    Half sunk a shattered visage lies, whose frown,\n    And wrinkled lip, and sneer of cold command,\n    Tell that its sculptor well those passions read\n    Which yet survive, stamped on these lifeless things,\n    The hand that mocked them, and the heart that fed;\n    And on the pedestal, these words appear:\n    My name is Ozymandias, King of Kings;\n    Look on my Works, ye Mighty, and despair!\n    Nothing beside remains. Round the decay\n    Of that colossal Wreck, boundless and bare\n    The lone and level sands stretch far away.\n    \"\"\";\n```\n\nInside of the this \"Multiline String Literal\" you don't need to escape quotation marks `\"`\nand you gain the ability to write newlines without having to use `\\n`.\n", "number": [9, 4], "sub_items": [], "path": "strings/multiline.md", "source_path": "strings/multiline.md", "parent_names": ["Strings"]}}, {"Chapter": {"name": "Concatenation", "content": "# Concatenation\n\nAny two strings can be concatenated by using the `+` operator.\n\n```java\nString he = \"he\";\nString llo = \"llo\";\n\nString hello = he + llo;\n\nSystem.out.println(hello);\n```\n\nThis will make a new `String` where the characters from the first one all appear followed by the characters in the second one.\n\nIf you try to concatenate a `String` to something that is not a `String`, like an `int` or a `double`,\nthen the result will be a new `String` with the characters from the \"string representation\" of that\nother thing.\n\n```java\nint numberOfApples = 5;\ndouble dollahs = 1.52;\n\nString message = \"I have \" + numberOfApples +\n    \" apples and $\" + dollahs + \" in my pocket.\";\n\nSystem.out.println(message);\n```\n", "number": [9, 5], "sub_items": [], "path": "strings/concatenation.md", "source_path": "strings/concatenation.md", "parent_names": ["Strings"]}}, {"Chapter": {"name": "Equality", "content": "# Equality\n\nYou can check if two `String`s have the same contents by using `.equals`.\n\n```java\nString lyricOne = \"Green, Green, Dress\";\nString lyricTwo = \"Green, Green, Dress\";\n\nboolean areSameLyric = lyricOne.equals(lyricTwo);\nboolean isMyName = lyricOne.equals(\"Bop Bop\");\n\nSystem.out.println(areSameLyric);\nSystem.out.println(isMyName);\n```\n\nYou write one `String` on the left, `.equals`, and then the `String` you want to check it\nagainst inside of parentheses.\n\nTo see if strings have different contents, you need to use the not operator (`!`) on\nthe result of `.equals`.\n\n```java\nString bow = \"bow\";\nString wow = \"WOW\";\n\nboolean areNotSame = !bow.equals(wow);\n\nSystem.out.println(areNotSame);\n```\n", "number": [9, 6], "sub_items": [], "path": "strings/equality.md", "source_path": "strings/equality.md", "parent_names": ["Strings"]}}, {"Chapter": {"name": "Length", "content": "# Length\n\nThe number of `char`s which comprise a `String` can be accessed by using `.length()`.[^codepoints]\n\n```java\nString fruit = \"strawberry\";\nint numberOfChars = fruit.length();\n\n// strawberry is 10 characters long\nSystem.out.println(\n    fruit + \" is \" numberOfChars + \" characters long\"\n);\n```\n\n[^codepoints]: This is different from the number of unicode codepoints.\n", "number": [9, 7], "sub_items": [], "path": "strings/length.md", "source_path": "strings/length.md", "parent_names": ["Strings"]}}, {"Chapter": {"name": "Access Individual Characters", "content": "# Access Individual Characters\n\nGiven a `String`, you can access the individual characters which\ncomprise it by using `.charAt`.\n\nThe first character can be accessed by putting `0` in the parentheses.\nThe second by using `1`, and so on.\n\n```java\nString spy = \"loid\";\n\nchar l = spy.charAt(0);\nSystem.out.println(l);\n\nchar o = spy.charAt(1);\nSystem.out.println(o);\n\nchar i = spy.charAt(2);\nSystem.out.println(i);\n\nchar d = spy.charAt(3);\nSystem.out.println(d);\n```\n\nWe call this number the \"index\" of the character.[^otherds]\n\nThe index of the character to access can come from a variable.\n\n```java\nString assassin = \"yor\";\nint indexOfR = 2;\n\nchar r = assassin.charAt(indexOfR);\nSystem.out.println(r);\n```\n\nIf you give a number equal to or greater than the length of the `String` or a number less than zero,\nyou will get an error.\n\n```java\nString student = \"anya\";\n// Crash!\nstudent.charAt(999);\n```\n\n```java\nString dog = \"bond\";\n// Crash!\ndog.charAt(-1);\n```\n\n[^otherds]:\n    There will be more things\n    which have their individual elements accessible by indexes. They will all generally start from 0 for the first element\n    but there are rare exceptions.\n", "number": [9, 8], "sub_items": [], "path": "strings/access_individual_characters.md", "source_path": "strings/access_individual_characters.md", "parent_names": ["Strings"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nRemember the rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\n## Challenge 1\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```Java\nvoid main() {\n    String first = \"1\";\n    String second = \"2\";\n    String result = first + second;\n\n    System.out.println(result);\n}\n```\n\n~ELSE\n\n```Java\npublic class Main {\n    public static void main(String[] args) {\n        String first = \"1\";\n        String second = \"2\";\n        String result = first + second;\n\n        System.out.println(result);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 2\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```Java\nvoid main() {\n    String first = \"1\";\n    int second = 2;\n\n    System.out.println(first + second);\n}\n```\n\n~ELSE\n\n```Java\npublic class Main {\n    public static void main(String[] args) {\n        String first = \"1\";\n        int second = 2;\n\n        System.out.println(first + second);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 3\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```Java\nvoid main() {\n    char first = 'a';\n    String second = \"b\";\n    String third = \"ab\";\n\n    System.out.println((first + second).equals(second));\n}\n```\n\n~ELSE\n\n```Java\npublic class Main {\n    public static void main(String[] args) {\n        char first = 'a';\n        String second = \"b\";\n        String third = \"ab\";\n\n        System.out.println((first + second).equals(second));\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 4\n\nMake it so this program will output `abc` by only changing one line and\nnot altering the `println` statement.\n\nBefore your change, why does it output `294`?\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    char a = 'a';\n    char b = 'b';\n    char c = 'c';\n    System.out.println(a + b + c);\n}\n```\n\n~ELSE\n\n```Java\npublic class Main {\n    public static void main(String[] args) {\n        char a = 'a';\n        char b = 'b';\n        char c = 'c';\n        // Change above this line\n        System.out.println(a + b + c);\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 5\n\nWithout adding any new `println`s,\nchange one line in this program so that it outputs `racecar`.\n\nTry to find two ways to do that.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    String racecar = \"racecar\";\n\n    int diff = 1;\n\n    int index = 6;\n\n    System.out.print(racecar.charAt(index));\n    index += diff;\n    System.out.print(racecar.charAt(index));\n    index += diff;\n    System.out.print(racecar.charAt(index));\n    index += diff;\n    System.out.print(racecar.charAt(index));\n    index += diff;\n    System.out.print(racecar.charAt(index));\n    index += diff;\n    System.out.print(racecar.charAt(index));\n    index += diff;\n    System.out.println(racecar.charAt(index));\n}\n```\n\n~ELSE\n\n```Java\npublic class Main {\n    public static void main(String[] args) {\n        String racecar = \"racecar\";\n\n        int diff = 1;\n\n        int index = 6;\n\n        System.out.print(racecar.charAt(index));\n        index += diff;\n        System.out.print(racecar.charAt(index));\n        index += diff;\n        System.out.print(racecar.charAt(index));\n        index += diff;\n        System.out.print(racecar.charAt(index));\n        index += diff;\n        System.out.print(racecar.charAt(index));\n        index += diff;\n        System.out.print(racecar.charAt(index));\n        index += diff;\n        System.out.println(racecar.charAt(index));\n    }\n}\n```\n\n~ENDIF\n", "number": [9, 9], "sub_items": [], "path": "strings/challenges.md", "source_path": "strings/challenges.md", "parent_names": ["Strings"]}}], "path": "strings.md", "source_path": "strings.md", "parent_names": []}}, {"PartTitle": "Control Flow I"}, {"Chapter": {"name": "Branching Paths", "content": "# Branching Paths\n\nAll the code I have shown you so far has run from top to bottom. That is, it has followed a single \"path.\"\n\nNot all programs can follow a single path though.\n\nImagine trying to rent a car online. The first thing you might be asked is your age.\nThis is because most car rental companies do not want to rent to people under the age of 25.[^insurance].\n\nIf you enter an age that is less than 25, the program should immediately tell you that you cannot\nrent a car. If you enter an age that is greater than or equal to 25, the program should continue to prompt you\nfor more information.\n\nThere are multiple \"branching paths\" that the program might take.\n\n[^insurance]: For insurance reasons.\n", "number": [10], "sub_items": [{"Chapter": {"name": "If", "content": "# If\n\nThe way to represent a branching path in Java is by using an `if` statement.\n\n```java\nint age = 5; // \ud83d\udc76\nif (age < 25) {\n    System.out.println(\"You are too young to rent a car!\");\n}\n```\n\nYou write the word `if` followed by an expression which evaluates to a `boolean` inside of `(` and `)`.\nThis expression is the \"condition\". Then you write some code inside\nof `{` and `}`.\n\n```java\nif (CONDITION) {\n    <CODE HERE>\n}\n```\n\nWhen the condition evaluates to `true`, the code inside of the `{` and `}` will run.\nIf it evaluates to `false` that code will not run.\n\nIn this example the condition is `age < 25`. When `age` is less than 25 it will evaluate to `true`\nand you will be told that you cannot rent a car.\n\n```java\nint age = 80; // \ud83d\udc75\nif (age < 25) {\n    System.out.println(\"You are too young to rent a car!\");\n}\n```\n\nIf this condition evaluates to `false`, then the code inside of `{` and `}`\nwill not run.\n", "number": [10, 1], "sub_items": [], "path": "branching_logic/if.md", "source_path": "branching_logic/if.md", "parent_names": ["Branching Paths"]}}, {"Chapter": {"name": "Else", "content": "# Else\n\nWhen you want to do one thing when a condition evaluates to `true`\nand another when that same condition evaluates to `false` you can use `else`.\n\n```java\nint age = 30; // \ud83d\ude4e\u200d\u2640\ufe0f\nif (age < 25) {\n    System.out.println(\"You cannot rent a car!\");\n}\nelse {\n    System.out.println(\"You might be able to rent a car.\");\n}\n```\n\nYou write the word `else` immediately after the `}` at the end of an `if` statement, then\nsome code inside of a new `{` and `}`.\n\n```java\nif (CONDITION) {\n    <CODE TO RUN>\n}\nelse {\n    <CODE TO RUN>\n}\n```\n\nWhen the condition evaluates to `false`, the code inside of `else`'s `{` and `}` will run.\n\n`else` cannot exist without a matching `if`, so this code does not work.\n\n```java\nelse {\n    System.out.println(\"No if.\");\n}\n```\n", "number": [10, 2], "sub_items": [], "path": "branching_logic/else.md", "source_path": "branching_logic/else.md", "parent_names": ["Branching Paths"]}}, {"Chapter": {"name": "Nested Ifs", "content": "# Nested Ifs\n\nThe code inside of the `{` and `}` can be anything, including more `if` statments.\n\n```java\nint age = 5; // \ud83d\udc76\nif (age < 25) {\n    System.out.println(\"You are too young to rent a car!\");\n    if (age == 24) {\n        System.out.println(\"(but it was close)\");\n    }\n}\n```\n\nWhen an `if` is inside another `if` we say that it is \"nested\".\n\nIf you find yourself nesting more than a few `if`s that might be a sign that\nyou should reach out for help.\n\n```java\nif (...) {\n    if (...) {\n        if (...) {\n            if (...) {\n                // Seek professional help\n            }\n        }\n    }\n}\n```\n", "number": [10, 3], "sub_items": [], "path": "branching_logic/nested_ifs.md", "source_path": "branching_logic/nested_ifs.md", "parent_names": ["Branching Paths"]}}, {"Chapter": {"name": "Else If", "content": "# Else If\n\nIf you have an `if` nested in an `else` branch, you can simplify that by using\n`else if`.\n\n```java\nboolean cool = true; // \ud83d\udd76\ufe0f\nint age = 30; // \ud83d\ude4e\u200d\u2640\ufe0f\nif (age < 25) {\n    System.out.println(\"You cannot rent a car!\");\n}\nelse {\n    if (!cool) {\n        System.out.println(\"You failed the vibe check.\");\n    }\n    else {\n        System.out.println(\"You are rad enough to rent a car.\");\n    }\n}\n```\n\nSo the following will work the same as the code above.\n\n```java\nboolean cool = true; // \ud83d\udd76\ufe0f\nint age = 30; // \ud83d\ude4e\u200d\u2640\ufe0f\n\nif (age < 25) {\n    System.out.println(\"You cannot rent a car!\");\n}\nelse if (!cool) {\n    System.out.println(\"You failed the vibe check.\");\n}\nelse {\n    System.out.println(\"You are rad enough to rent a car.\");\n}\n```\n\nYou can have as many `else if`s as you need. Each one will only run if all the previous conditions\nevaluate to `false`.\n\n```java\nboolean cool = true; // \ud83d\udd76\ufe0f\nint age = 100; // \ud83d\udc74\n\nif (age < 25) {\n    System.out.println(\"You cannot rent a car!\");\n}\nelse if (!cool) {\n    System.out.println(\"You failed the vibe check.\");\n}\nelse if (age > 99) {\n    System.out.println(\"You are too old to safely drive a car!\");\n}\nelse if (age > 450) {\n    System.out.println(\"There can only be one! \u2694\ufe0f\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc73\udb40\udc63\udb40\udc74\udb40\udc7f\");\n}\nelse {\n    System.out.println(\"You are rad enough to rent a car.\");\n}\n```\n", "number": [10, 4], "sub_items": [], "path": "branching_logic/else_if.md", "source_path": "branching_logic/else_if.md", "parent_names": ["Branching Paths"]}}, {"Chapter": {"name": "Relation to Delayed Assignment", "content": "# Relation to Delayed Assignment\n\nDelayed assignment of variables becomes useful with `if` and `else`.\n\nSo long as Java can figure out that a variable will always be given an initial value\ninside of an `if` and `else`, you will be allowed to use that variable.\n\n```java\nint age = 22;\n\nString message;\nif (age > 25) {\n    message = \"You might be able to rent a car\";\n}\nelse {\n    message = \"You cannot rent a car!\";\n}\n\nSystem.out.println(message);\n```\n\nIf it will not always be given an initial value, then you will not be allowed to\nuse that variable.\n\n```java\nint age = 22;\n\nString message;\nif (age > 25) {\n    message = \"You might be able to rent a car\";\n}\n\n// message is not always given an initial value\n// so you cannot use it.\nSystem.out.println(message);\n```\n", "number": [10, 5], "sub_items": [], "path": "branching_logic/relation_to_delayed_assignment.md", "source_path": "branching_logic/relation_to_delayed_assignment.md", "parent_names": ["Branching Paths"]}}, {"Chapter": {"name": "Conditional Operator", "content": "# Conditional Operator\n\nWhen the only operation being performed inside of an `if` and `else` pair\nis setting the initial value of a variable, you can use the \"conditional operator\"[^ternary]\nto perform that assignment instead.\n\n```java\nint age = 22;\n\nString message = age < 25\n    ? \"You cannot rent a car!\"\n    : \"You might be able to rent a car\";\n```\n\nYou write a condition followed by a `?`, a value to use when that condition evaluates to `true`, a `:`,\nand then a value to use when that condition evaluates to `false`.\n\n```java\nCONDITION ? WHEN_TRUE : WHEN_FALSE\n```\n\n[^ternary]:\n    Some people will call this a ternary expression. Ternary meaning \"three things.\"\n    Same idea as tres leches.\n", "number": [10, 6], "sub_items": [], "path": "branching_logic/conditional_operator.md", "source_path": "branching_logic/conditional_operator.md", "parent_names": ["Branching Paths"]}}, {"Chapter": {"name": "Boolean Expressions", "content": "# Boolean Expressions\n\nA common thing I've seen students do is set the initial value of some\n`boolean` variable based on some condition.\n\n```java\nint age = 22;\n\nboolean canRent;\nif (age > 25) {\n    canRent = true;\n}\nelse {\n    canRent = false;\n}\n\n// or\n// boolean canRent = age > 25 ? true : false;\n\nSystem.out.println(canRent);\n```\n\nThis is valid code, but very often can be made simpler if you remember that the condition\nitself already evaluates to a `boolean`. You can directly assign the variable to that value.\n\n```java\nint age = 22;\nboolean canRent = age > 25;\n\nSystem.out.println(canRent);\n```\n", "number": [10, 7], "sub_items": [], "path": "branching_logic/boolean_expressions.md", "source_path": "branching_logic/boolean_expressions.md", "parent_names": ["Branching Paths"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nRemember the rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\n## Challenge 1\n\nWrite code that will outputs `The number is even` if `x` is an even number.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    // Change this variable to different numbers\n    // to test your code\n    int x = 5;\n\n    // < YOUR CODE HERE >\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // Change this variable to different numbers\n        // to test your code\n        int x = 5;\n\n        // < YOUR CODE HERE >\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 2\n\nMake it so that your code from the previous problem will also output `The number is odd`\nif the number is odd.\n\n## Challenge 3\n\nWrite code that will output `allowed` if the the `password` variable is equal to\n`\"abc123\"` and `not allowed` if it isn't.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    // Change this variable to different strings\n    // to test your code\n    String password = \"apple\";\n\n    // < YOUR CODE HERE >\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // Change this variable to different strings\n        // to test your code\n        String password = \"apple\";\n\n        // < YOUR CODE HERE >\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 4\n\nWrite code that will assign the string `The number is {x} even` to `message` if `x` is an even number\nand `The number is {x} odd` if `x` is an even number.\n\nSo if `x` is 12 the string you should assign `The number 12 is even` to `message`.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    String message;\n\n    // Change this variable to different numbers\n    // to test your code\n    int x = 5;\n\n    // < YOUR CODE HERE >\n\n    System.out.println(message);\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String message;\n\n        // Change this variable to different numbers\n        // to test your code\n        int x = 5;\n\n        // < YOUR CODE HERE >\n\n        System.out.println(message);\n    }\n}\n```\n\n~ENDIF\n", "number": [10, 8], "sub_items": [], "path": "branching_logic/challenges.md", "source_path": "branching_logic/challenges.md", "parent_names": ["Branching Paths"]}}], "path": "branching_paths.md", "source_path": "branching_paths.md", "parent_names": []}}, {"Chapter": {"name": "Loops", "content": "# Loops\n\n`if` and `else` let you write programs which can take branching paths,\nbut they will still run from the beginning to the end.\n\nNot all programs can just _end_ though.\nVideo games should draw their world at one second and do it again the next.\nIf you enter the wrong password on your phone, it should ask you for your password again.\n\nThis is what \"loops\" are for. You run code starting from some point and then\nloop back to that same point and run that code again.\n", "number": [11], "sub_items": [{"Chapter": {"name": "While", "content": "# While\n\nOne way to make a loop in code is to use `while`.\n\n```java\nint x = 5;\nwhile (x != 0) {\n    System.out.println(x);\n    x--;\n}\n```\n\nYou write `while` followed by a condition inside of `(` and `)` and some code inside of `{` and `}`.\n\n```java\nwhile (CONDITION) {\n    <CODE HERE>\n}\n```\n\nIf the condition evaluates to `true` then the code inside of `{` and `}` will run.\nAfter that code runs, the condition will be evaluated again. If it still evaluates to\n`true` then the code `{` and `}` will run again.\n\nThis will continue until the code in the condition evaluates to `false`.\n\n```java\nint glassesOfMilk = 99;\nwhile (glassesOfMilk > 0) {\n    System.out.println(\n        glassesOfMilk + \" glasses of milk left\"\n    );\n\n    glassesOfMilk--;\n}\n```\n\nIf a loop is made with `while` we call it a \"while loop.\"[^tortoise]\n\n[^tortoise]: \"We called him Tortoise because he taught us.\" - Lewis Carroll\n", "number": [11, 1], "sub_items": [], "path": "loops/while.md", "source_path": "loops/while.md", "parent_names": ["Loops"]}}, {"Chapter": {"name": "Endless Loops", "content": "# Endless Loops\n\nIf a while loop will never end, we call that an endless loop.\n\nThis can happen if the condition is a constant like `while (true)`\n\n```java\nwhile (true) {\n    System.out.println(\"This is the song that never ends\");\n}\n```\n\nOr if the variables tested in the condition are not updated inside of the loop.\n\n```java\n// x is never changed\nint x = 0;\nwhile (x != 1) {\n    System.out.println(\"It goes on and on my friends\");\n}\n```\n\nMany games should never really \"finish\" so at the very start of that sort of program it is not uncommon\nto see a `while (true)`.\n", "number": [11, 2], "sub_items": [], "path": "loops/endless_loops.md", "source_path": "loops/endless_loops.md", "parent_names": ["Loops"]}}, {"Chapter": {"name": "Break", "content": "# Break\n\nWhile loops will usually stop running when the condition at the top evaluates\nto `false`.\n\nThis can be bypassed by using the `break` statement.\n\n```java\nint x = 5;\nwhile (x > 0) {\n    if (x == 2) {\n        break;\n    }\n    x--;\n}\n\nSystem.out.println(\n    \"Final value of x is \" + x\n);\n```\n\nIf a `break` is reached, the code in the loop stops running immediately.\nThe condition of the loop is not checked again.\n\nThis can be useful in a variety of situations, but notably it is the only way to exit\nfrom an otherwise endless loop.\n\n```java\nwhile (true) {\n    System.out.println(\n        \"The people started singing it not knowing what it was\"\n    );\n\n    // Will immediately leave the loop\n    break;\n}\n```\n", "number": [11, 3], "sub_items": [], "path": "loops/break.md", "source_path": "loops/break.md", "parent_names": ["Loops"]}}, {"Chapter": {"name": "Continue", "content": "# Continue\n\nUnless there is a `break`, while loops will usually run all the code in their body from top to bottom.\n\nThe only other situation this will not happen is if a `continue` statement is reached.\n\n```java\n// Will output a message for every number except 4\nint x = 5;\nwhile (x > 0) {\n    if (x == 4) {\n        continue;\n    }\n    System.out.println(x + \" is a good number\");\n    x--;\n}\n```\n\nIf a `continue` is reached the code in the loop stops running immediately but, unlike `break`,\nthe condition of the loop _is_ checked again. If it still evaluates to `true` then the code\nin the loop will run again.\n", "number": [11, 4], "sub_items": [], "path": "loops/continue.md", "source_path": "loops/continue.md", "parent_names": ["Loops"]}}, {"Chapter": {"name": "Unreachable Code", "content": "# Unreachable Code\n\nIf you write some code directly after a `break` or `continue`\nthat code will be \"unreachable.\"\n\nJava knows this and so won't let any code like that run.\n\n```java\n// This will not work\nwhile (true) {\n    continue;\n\n    System.out.println(\"this is unreachable\");\n}\n```\n", "number": [11, 5], "sub_items": [], "path": "loops/unreachable_code.md", "source_path": "loops/unreachable_code.md", "parent_names": ["Loops"]}}, {"Chapter": {"name": "Do While", "content": "# Do\n\nOne variation on a `while` loop is a \"do-while loop.\"\n\n```java\nint x = 0;\ndo {\n    System.out.println(x);\n    x++\n} while(x < 5);\n```\n\nYou write `do`, some code inside of `{` and `}`, and then `while`, a condition inside of\n`(` and `)`, and finally a semicolon.\n\n```java\ndo {\n    <CODE HERE>\n} while (CONDITION);\n```\n\nIn most situations it works exactly the same as a regular while loop. The only difference\nis that the first time the loop is reached the condition for the loop is not checked.\n\n```java\nint x = 0;\ndo {\n    System.out.println(\"this will run\");\n} while (x != 0)\n\nwhile (x != 0) {\n    System.out.println(\"this will not run\");\n}\n```\n\nOne way to remember the difference is that in a \"do-while loop\" you always \"do the thing\"\nat least once.\n", "number": [11, 6], "sub_items": [], "path": "loops/do_while.md", "source_path": "loops/do_while.md", "parent_names": ["Loops"]}}, {"Chapter": {"name": "Nested Loops", "content": "# Nested Loops\n\nJust like with `if`, The code inside of the `{` and `}` can be anything, including more loops.\n\n```java\nint x = 5;\nint y = 3;\n\nwhile (x != 0) {\n    while (y != 0) {\n        System.out.println(\n            \"x is \" + x\n        );\n        System.out.println(\n            \"y is \" + y\n        );\n\n        x--;\n        y--;\n    }\n}\n```\n\nIf you are inside such a \"nested loop\", `continue` and `break` apply to the\n\"closest\" loop.\n\nThat is, if a `continue` or a `break` were to appear here\n\n```java\nwhile (x != 0) {\n    while (y != 0) {\n        if (y == 2) {\n            break;\n        }\n\n        System.out.println(\n            \"x is \" + x\n        );\n        System.out.println(\n            \"y is \" + y\n        );\n\n        x--;\n        y--;\n    }\n}\n```\n\nThen the `y != 0` loop will be broken out of, not the `x != 0` one.\nAnd if a `continue` or a `break` were to appear here\n\n```java\nwhile (x != 0) {\n    if (x == 2) {\n        break;\n    }\n    while (y != 0) {\n\n\n        System.out.println(\n            \"x is \" + x\n        );\n        System.out.println(\n            \"y is \" + y\n        );\n\n        x--;\n        y--;\n    }\n}\n```\n\nThen the `x != 0` loop would be the \"target.\"\n", "number": [11, 7], "sub_items": [], "path": "loops/nested_loops.md", "source_path": "loops/nested_loops.md", "parent_names": ["Loops"]}}, {"Chapter": {"name": "Labeled Break", "content": "# Labeled Break\n\nIf you want to break out of a nested loop from one of the inner loops, you can use a \"labeled break.\"\n\n```java\nouterLoop:\nwhile (true) {\n    while (true) {\n        break outerLoop;\n    }\n}\n```\n\nTo do this, before your outer while or do-while loop you need to add a \"label\" followed by a `:`.\nA label is an arbitrary name just like a variable's name.\n\n```java\n<LABEL>:\nwhile (<CONDITION>) {\n    <CODE HERE>\n}\n```\n\n```java\n<LABEL>:\ndo {\n    <CODE HERE>\n} while (<CONDITION>);\n```\n\nThen inside of an inner loop, you just need to write `break` followed by the label name.\n\n```java\nint x = 5;\nint y = 3;\n\nxLoop:\nwhile (x != 0) {\n    while (y != 0) {\n        if (x == 2 && y == 2) {\n            break xLoop;\n        }\n\n        System.out.println(\n            \"x is \" + x\n        );\n        System.out.println(\n            \"y is \" + y\n        );\n\n        x--;\n        y--;\n    }\n}\n\nSystem.out.println(\"done.\")\n```\n\nIn this case the `x != 0` loop will be broken out of, not the `y != 0` one.\n", "number": [11, 8], "sub_items": [], "path": "loops/labeled_break.md", "source_path": "loops/labeled_break.md", "parent_names": ["Loops"]}}, {"Chapter": {"name": "Labeled Continue", "content": "# Labeled Continue\n\nIn the same way a labeled break can break out of a nested loop, a labeled continue\ncan jump back to the start of a nested loop.\n\nYou just write `continue` followed by the label name.\n\n```java\n// Will keep going back to the top of the outer loop\nouterLoop:\nwhile (true) {\n    System.out.println(\"inside outer loop\");\n    while (true) {\n        System.out.println(\"inside inner loop\");\n        continue outerLoop;\n    }\n}\n```\n", "number": [11, 9], "sub_items": [], "path": "loops/labeled_continue.md", "source_path": "loops/labeled_continue.md", "parent_names": ["Loops"]}}, {"Chapter": {"name": "Iteration", "content": "# Iteration\n\nLoops potentially run code multiple times. Each time one goes from its top to its bottom\nwe call that an \"iteration\" of the loop.\n\n```java\nint x = 0;\nwhile (x < 5) {\n    // On the 1st iteration x will be 0\n    // On the 2nd iteration x will be 1\n    // ...\n    // On the final iteration x will be 4\n    System.out.println(x);\n    x++\n}\n```\n\nWhen the purpose of a loop is to run for every thing in some sequence of things,\nwe say that the loop is \"iterating over\" those things.\n", "number": [11, 10], "sub_items": [], "path": "loops/iteration.md", "source_path": "loops/iteration.md", "parent_names": ["Loops"]}}, {"Chapter": {"name": "Counting Up", "content": "# Counting Up\n\nSay your loop is intended to run some code for every number from `1` to `100`.\n\nThe general pattern for code like this is to have some variable which tracks the current\nnumber, a loop whose condition is that the number is less than the number you want\nto stop at, and a line at the bottom of the loop which increments the current number.\n\n```java\nint currentNumber = 1;\nwhile (currentNumber <= 100) {\n    System.out.println(currentNumber);\n    currentNumber++;\n}\n```\n\nTake note that in this example the condition is `currentNumber <= 100`, so the code in the\nloop will run when `currentNumber` is equal to `100`. If the condition was `currentNumber < 100`\nit would stop at `99`.\n\n```java\nint currentNumber = 1;\n// Stops at 99\nwhile (currentNumber < 100) {\n    System.out.println(currentNumber);\n    currentNumber++;\n}\n```\n", "number": [11, 11], "sub_items": [], "path": "loops/counting_up.md", "source_path": "loops/counting_up.md", "parent_names": ["Loops"]}}, {"Chapter": {"name": "Counting Down", "content": "# Counting Down\n\nIf you want to do the opposite, starting from a number like `100` and count down to `1`,\nthe pattern will be similar.\n\nYou still have some variable tracking the current\nnumber, but with a loop whose condition is that the number is greater than the number you want\nto stop at, and a line at the bottom of the loop which decrements the current number.\n\n```java\nint currentNumber = 100;\nwhile (currentNumber >= 1) {\n    System.out.println(currentNumber);\n    currentNumber--;\n}\n```\n\nSimilar to when counting up if the condition was not `currentNumber >= 1` and instead was\n`currentNumber > 1`, the loop would stop at `2`\n\n```java\nint currentNumber = 100;\n// Stops at 2\nwhile (currentNumber > 1) {\n    System.out.println(currentNumber);\n    currentNumber--;\n}\n```\n", "number": [11, 12], "sub_items": [], "path": "loops/counting_down.md", "source_path": "loops/counting_down.md", "parent_names": ["Loops"]}}, {"Chapter": {"name": "Iterate over a String", "content": "# Iterate over a String\n\nThis general pattern of counting up and counting down becomes\nespecially useful when you want to iterate over each character in\na `String`.\n\n```java\nString name = \"Avril\";\n\nint index = 0;\nwhile (index < name.length()) {\n    System.out.println(name.charAt(index));\n    index++;\n}\n```\n", "number": [11, 13], "sub_items": [], "path": "loops/iterate_over_a_string.md", "source_path": "loops/iterate_over_a_string.md", "parent_names": ["Loops"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nEarly on, most students tend to have a lot of trouble with loops.\nIts also what is quizzed on in a lot of standardized tests.\n\nBecause of that there will be a lot of challenges in this section for you\nto practice. Try to at least do the first ten or so to make sure you have\nthe concept down, but the more the better.\n\nIt might take awhile before you feel truly comfortable with this. That is normal.\n\nRemember the rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\n## Challenge 1\n\nWrite code that outputs every number from `1` to `10`.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    <CODE HERE>\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        <CODE HERE>\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 2\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    int x = 0;\n    while (x < 10) {\n        System.out.println(x);\n        x++;\n    }\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int x = 0;\n        while (x < 10) {\n            System.out.println(x);\n            x++;\n        }\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 3\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    int x = 0;\n    while (x <= 10) {\n        System.out.println(x);\n        x++;\n    }\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int x = 0;\n        while (x <= 10) {\n            System.out.println(x);\n            x++;\n        }\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 4\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    int x = 0;\n    while (x < 10) {\n        if (x % 3 == 0) {\n            break;\n        }\n        System.out.println(x);\n        x++;\n    }\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int x = 0;\n        while (x < 10) {\n            if (x % 3 == 0) {\n                break;\n            }\n            System.out.println(x);\n            x++;\n        }\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 5\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    int x = 0;\n    while (x < 10) {\n        if (x % 3 == 0) {\n            continue;\n        }\n        System.out.println(x);\n        x++;\n    }\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        int x = 0;\n        while (x < 10) {\n            if (x % 3 == 0) {\n                continue;\n            }\n            System.out.println(x);\n            x++;\n        }\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 6\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    int x = 1;\n    while (x < 10) {\n        int y = 2;\n        while (y < 5) {\n            System.out.println(x * y);\n            y++;\n        }\n\n        x++;\n    }\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int x = 1;\n        while (x < 10) {\n            int y = 2;\n            while (y < 5) {\n                System.out.println(x * y);\n                y++;\n            }\n\n            x++;\n        }\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 7\n\nWhat will this program output when run? Write down your guess and then try running it.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    <CODE HERE>\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int x = 0;\n        String scream = \"a\";\n        while (!scream.equals(\"aaaaaaaa\")) {\n            scream = scream + \"a\";\n            System.out.println(x);\n            System.out.println(scream);\n        }\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 8\n\nWrite code that will output each character of `name` on its own line.\n\nSo for if `name` is equal to `\"Bridget\"`, I would expect the following as output.\n\n```text\nB\nr\ni\nd\ng\ne\nt\n```\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    <CODE HERE>\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // Change this value to test your code.\n        String name = \"Bridget\";\n\n        // <CODE HERE>\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 9\n\nWrite code that will output each character of `name` on its own line, starting with the last\ncharacter and going backwards.\n\nSo for if `name` is equal to `\"Samantha\"`, I would expect the following as output.\n\n```text\na\nh\nt\nn\na\nm\na\nS\n```\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    // Change this value to test your code.\n    String name = \"Samantha\";\n\n    // <CODE HERE>\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // Change this value to test your code.\n        String name = \"Samantha\";\n\n        // <CODE HERE>\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 10\n\nWrite code that will take a number and if it is divisible by two, divides it by two.\nIf it is not, multiplies it by three and adds one.\n\nKeep doing this until the number equals one. Output it each time.\n\nIf the initial number is `6` you should have this as output.\n\n```text\n6\n3\n10\n5\n16\n8\n4\n2\n1\n```\n\nIf the initial number is `15` you should have this as output.\n\n```text\n15\n46\n23\n70\n35\n106\n53\n160\n80\n40\n20\n10\n5\n16\n4\n2\n1\n```\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    // Change this value to test your code.\n    int n = 15;\n\n    // <CODE HERE>\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // Change this value to test your code.\n        int n = 15;\n\n        // <CODE HERE>\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 11\n\nWrite code that outputs every third number from `37` to `160`.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    <CODE HERE>\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        <CODE HERE>\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 12\n\nWrite code that outputs the number of vowels in `name`. Treat `y` as a vowel.\n\nTreat the characters `a`, `A`, `e`, `E`, `i`, `I`, `o`, `O`, `u`, `U`, `y`, and `Y` as vowels.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    // Change this value to test your code.\n    String name = \"Damian\";\n\n    // <CODE HERE>\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // Change this value to test your code.\n        String name = \"Damian\";\n\n        // <CODE HERE>\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 13\n\nWrite code that outputs `{name} is mostly vowels` if the number of vowels in `name` is greater\nthan the number of consonants. and `{name} is mostly consonants` if the opposite is true.\nOutput `{name} has an equal number of vowels and consonants` if the count of both is the\nsame.\n\nMake sure to not treat non-alphabetic characters like `!` and `?` as consonants.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    // Change this value to test your code.\n    String name = \"Messi\";\n\n    // <CODE HERE>\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // Change this value to test your code.\n        String name = \"Messi\";\n\n        // <CODE HERE>\n    }\n}\n```\n\n~ENDIF\n\n## Challenge 14\n\nRewrite the following code to not have the `shouldBreak` variable\nand instead to use a labeled break.\n\n~IF toplevel_anonymous_class\n\n```java\nvoid main() {\n    // Don't think too hard about what these numbers mean.\n    int x = 3;\n    int y = 0;\n\n    boolean shouldBreak = false;\n    while (shouldBreak && x < 100) {\n        while (y < 100) {\n            System.out.println(\"x is \" + x);\n            System.out.println(\"y is \" + y);\n            x = x * y;\n            if (x == 0) {\n                shouldBreak = true;\n                break;\n            }\n            y++;\n        }\n    }\n\n    System.out.println(\"Done\");\n}\n```\n\n~ELSE\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // Don't think too hard about what these numbers mean.\n        int x = 3;\n        int y = 0;\n\n        boolean shouldBreak = false;\n        while (shouldBreak && x < 100) {\n            while (y < 100) {\n                System.out.println(\"x is \" + x);\n                System.out.println(\"y is \" + y);\n                x = x * y;\n                if (x == 0) {\n                    shouldBreak = true;\n                    break;\n                }\n                y++;\n            }\n        }\n\n        System.out.println(\"Done\");\n    }\n}\n```\n\n~ENDIF\n", "number": [11, 14], "sub_items": [], "path": "loops/challenges.md", "source_path": "loops/challenges.md", "parent_names": ["Loops"]}}], "path": "loops.md", "source_path": "loops.md", "parent_names": []}}, {"PartTitle": "Data Types II"}, {"Chapter": {"name": "Arrays", "content": "# Arrays\n\nArrays are used to represent a fixed-size collection of things.\n\n```java\nint[] oddNumbers = { 1, 3, 5, 7, 9 };\n```\n\nFixed-size means that once an array is made, it will always hold the same\nnumber of things.\n\nWe call the things stored in an array its \"elements.\"\n\nYou can make an array of any type of element by using the name of the type followed by\n`[]`.\n\n```java\nchar[] letters = { 'a', 'b', 'c' };\nString[] words = { \"its\", \"as\", \"easy\", \"as\" }\nint[] numbers = { 1, 2, 3 };\ndouble[] doubles = { 97.0, 98.0, 99.0, 1.0, 2.0, 3.0 };\n```\n", "number": [12], "sub_items": [{"Chapter": {"name": "Array Initializers", "content": "# Array Initializers\n\nTo give an initial value to an array you can use an array initializer.\n\nAfter the equals sign you write `{` followed by a comma separated list of elements and a final `}`.\n\n```java\nint[] numbers = { 1, 2, 3 }\n             // |---------|\n             // this part is\n             // the initializer\n```\n\nThe elements in an initializer do not have to be literals and can also be variables or expressions.\n\n```java\nint two = 2;\n// Will hold 1, 2, 3 just like the array above\nint[] numbers = { 1, two, two + 1 }\n```\n\nWe call them array initializers because you use them to give an initial value to an array.[^pattern]\n\n[^pattern]:\n    You may be noticing a pattern. Confusing sounding names are often kinda \"obvious\"\n    with enough context.\n", "number": [12, 1], "sub_items": [], "path": "arrays/array_initializers.md", "source_path": "arrays/array_initializers.md", "parent_names": ["Arrays"]}}, {"Chapter": {"name": "Length", "content": "# Length\n\nThe number of elements which comprise an array can be accessed by using `.length`.[^unlike_string]\n\n```java\nString[] veggies = { \"brussels\", \"cabbage\", \"carrots\" };\nint numberOfElements = veggies.length;\n\n// veggies is 3 elements long\nSystem.out.println(\n    \"veggies is \" numberOfElements + \" characters long\"\n);\n```\n\n[^unlike_string]: Unlike with a `String`, you do not write `()` after `.length`.\n", "number": [12, 2], "sub_items": [], "path": "arrays/length.md", "source_path": "arrays/length.md", "parent_names": ["Arrays"]}}, {"Chapter": {"name": "Access Individual Elements", "content": "# Access Individual Elements\n\nGiven an array, you can access any of its elements by index.\n\nYou write the name of a variable containing an array, `[`, a number, and then a `]`.\n\nThe first element can be accessed by using `0`, the second by using `1`, and so on.\n\n```java\nString[] lyrics = { \"you\", \"say\", \"goodbye\" };\n\nString you = lyrics[0];\nSystem.out.println(you);\n\nString say = lyrics[1];\nSystem.out.println(say);\n\nString goodbye = lyrics[2];\nSystem.out.println(goodbye);\n```\n\nThe index of the element can also come from a variable.\n\n```java\nint index = 2;\nString[] lyrics = { \"I\", \"say\", \"hello\" };\n\nSystem.out.println(lyrics[index]);\n```\n\nIf you give a number equal to or greater than the length of the array or a number less than zero,\nyou will get an error.\n\n```java\nString[] lyrics = { \"I\", \"say\", \"hi\" };\n// Crash!\nlyrics[999];\n```\n\n```java\nString[] lyrics = { \"you\", \"say\", \"low\" };\n// Crash!\nlyrics[-1];\n```\n", "number": [12, 3], "sub_items": [], "path": "arrays/access_individual_elements.md", "source_path": "arrays/access_individual_elements.md", "parent_names": ["Arrays"]}}, {"Chapter": {"name": "Set Individual Elements", "content": "# Set Individual Elements\n\nYou can also set any of the elements of an array to have a new value.\n\nTo do this, on the left hand side of an equals sign you write the name of a variable\nfollowed by `[`, an index, and `]`. Then on the right hand side of the equals you write\nthe new value.[^strings]\n\n```java\nString[] sentence = { \"you\", \"are\", \"found\", \"guilty\" };\nSystem.out.println(sentence);\n\nsentence[1] = \"aren't\";\nSystem.out.println(sentence);\n```\n\nThe index of the element to set can also come from a variable.\n\n```java\nint index = 2;\nString[] response = { \"and\", \"it\", \"isn't\", \"opposite\", \"day\" };\nSystem.out.println(response);\n\nresponse[2] = \"is\";\nSystem.out.println(response);\n```\n\nIf you give a number equal to or greater than the length of the array or a number less than zero, you will get an error.\n\n```java\nString[] response = { \"objection\" };\n// Crash\nresponse[1] = \"!\";\n```\n\n```java\nString[] response = { \"sustained\" };\n// Crash\nresponse[-1] = \"not\";\n```\n\n[^strings]:\n    You cannot change the contents of a `String` like you would an array. This is one of the biggest\n    differences between a `String` and a `char[]`.\n", "number": [12, 4], "sub_items": [], "path": "arrays/set_individual_elements.md", "source_path": "arrays/set_individual_elements.md", "parent_names": ["Arrays"]}}, {"Chapter": {"name": "Aliasing", "content": "# Aliasing\n\nWhen you assign a variable containing an array to another variable, the array\nreferenced by both variables will be the exact same.\n\nThis means that if the contents of the array are updated, that change will\nbe reflected by both variables.\n\n```java\nchar[] lettersOne = { 'B', 'a', 't', 'm', 'a', 'n' };\nchar[] lettersTwo = lettersOne;\n\n// Batman\nSystem.out.println(lettersOne);\n// Batman\nSystem.out.println(lettersTwo);\n\nlettersOne[0] = 'C';\n\n// Catman\nSystem.out.println(lettersOne);\n// Catman\nSystem.out.println(lettersTwo);\n\nlettersTwo[0] = 'R';\n\n// Ratman\nSystem.out.println(lettersOne);\n// Ratman\nSystem.out.println(lettersTwo);\n```\n\nWhen two variables point to the same thing like this we say that both variables are \"aliases\"\nfor eachother.\n", "number": [12, 5], "sub_items": [], "path": "arrays/aliasing.md", "source_path": "arrays/aliasing.md", "parent_names": ["Arrays"]}}, {"Chapter": {"name": "Reassignment", "content": "# Reassignment\n\nThe length of an array cannot change, but a variable holding an\narray can be reassigned to a new array that has a different length.\n\n```java\nint[] numbers = { 1, 2 };\n// 2\nSystem.out.println(numbers.length);\n\nnumbers = { numbers[0], numbers[1], 3 };\n// 3\nSystem.out.println(numbers.length);\n```\n\nThis reassignment will not be affect any variables which\nare aliases for the variable's old value.\n\n```java\nchar[] wordOne = { 'g', 'o' };\nchar[] wordTwo = wordOne;\n// go\nSystem.out.println(wordOne);\n// go\nSystem.out.println(wordTwo);\n\nwordOne = { wordOne[0], wordOne[1], 's', 'h' };\n\n// gosh\nSystem.out.println(wordOne);\n// go\nSystem.out.println(wordTwo);\n\nwordTwo[0] = 'n';\n\n// gosh\nSystem.out.println(wordOne);\n// no\nSystem.out.println(wordTwo);\n\nwordOne[0] = 'p';\n\n// posh\nSystem.out.println(wordOne);\n// no\nSystem.out.println(wordTwo);\n```\n", "number": [12, 6], "sub_items": [], "path": "arrays/reassignment.md", "source_path": "arrays/reassignment.md", "parent_names": ["Arrays"]}}, {"Chapter": {"name": "Relation to Final Variables", "content": "# Relation to Final Variables\n\nJust like anything else, arrays can be stored in variables marked `final`.\n\nThis means that the variable cannot be reassigned, but it does not mean\nthat the array's contents cannot be changed directly or through an alias.\n\n```java\nfinal char[] catchphrase = { 'w', 'o', 'a', 'h', '!' };\n// woah!\nSystem.out.println(catchphrase);\n\n// Cannot reassign\n// catchphrase = { 'e', 'g', 'a', 'd', 's' }\n// but can set elements directly\ncatchphrase[0] = 'e';\ncatchphrase[1] = 'g';\n\n// or through an alias\nchar[] alias = catchphrase;\nalias[2] = 'a';\nalias[3] = 'd';\nalias[4] = 's';\n\n// egads\nSystem.out.println(catchphrase);\n```\n", "number": [12, 7], "sub_items": [], "path": "arrays/relation_to_final_variables.md", "source_path": "arrays/relation_to_final_variables.md", "parent_names": ["Arrays"]}}, {"Chapter": {"name": "Printing the Contents of an Array", "content": "# Printing the Contents of an Array\n\nIf you try to use `System.out.println` to output a `String[]`\nyou won't see the contents of the array. Instead you will see\nsomething like `[Ljava.lang.String;@1c655221`.\n\n```java\nString[] shout = { \"fus\", \"ro\", \"dah\" };\n// [Ljava.lang.String;@5a07e868\nSystem.out.println(shout);\n```\n\nA similar thing will happen with `int[]`, `boolean[]`, and `double[]`.[^gibberish]\n\n```java\nint[] nums = { 11, 11, 11 };\n// [I@5a07e868\nSystem.out.println(nums);\n\nboolean[] bools = { true, false };\n// [Z@5a07e868\nSystem.out.println(bools);\n\ndouble[] doubles = { 1.1, 1.1, 1.1 };\n// [D@5a07e868\nSystem.out.println(bools);\n```\n\nThe only kind of array which will include its contents when printed is a `char[]`.\nIt will be printed as if it were a `String`.\n\n```java\nchar[] continent = { 'T', 'a', 'm', 'r', 'i', 'e', 'l' };\n// Tamriel\nSystem.out.println(continent);\n```\n\nIf you want to actually see the contents of an array, you should\nuse a loop.[^future]\n\n```java\nString[] factions = { \"empire\", \"stormcloaks\", \"dragons\" };\n\nint index = 0;\nwhile (index < factions.length) {\n    System.out.println(factions[index])\n    index++\n}\n```\n\n[^gibberish]:\n    What `[I@5a07e868` and co. mean isn't really important. Try not to\n    get too distracted by it.\n\n[^future]:\n    Later on, there will be easier ways to do this sort of inspection. This is just the\n    one I can demonstrate now.\n", "number": [12, 8], "sub_items": [], "path": "arrays/printing_the_contents_of_an_array.md", "source_path": "arrays/printing_the_contents_of_an_array.md", "parent_names": ["Arrays"]}}, {"Chapter": {"name": "Empty Array", "content": "# Empty Array\n\nIf you use an array initializer that has no elements between the `{` and `}`\nyou can create an empty array.\n\n```java\nchar[] emptyCharArray = {};\n```\n\nAn empty array is very similar to an empty `String`. It has a length of 0, it has no elements,\nand it is generally useful only as a placeholder value for when you have no data yet but will\nbe able to reassign the variable holding it when you get some.\n\n```java\nchar[] emptyCharArray = {};\n\n// 0\nSystem.out.println(emptyCharArray.length);\n\n// Crash\nSystem.out.println(emptyCharArray[0]);\n```\n", "number": [12, 9], "sub_items": [], "path": "arrays/empty_array.md", "source_path": "arrays/empty_array.md", "parent_names": ["Arrays"]}}, {"Chapter": {"name": "Difference between Initializer and Literal", "content": "# Difference between Initializer and Literal\n\nThe reason `{ 1, 2, 3 }` is called an \"array initializer\" and not\nan \"array literal\" is somewhat subtle.\n\nWhen you have a literal, like a `String` literal, you can assign that to a variable and\nthen use that `String` afterwards.\n\n```java\nString name = \"Alana\";\n// l\nSystem.out.println(name.charAt(1));\n```\n\nBut you can also perform those operations using the literal itself, without an intermediate variable.\n\n```java\n// l\nSystem.out.println(\"Alana\".charAt(1));\n```\n\nArray initializers work in the case where you first assign them to a variable before using\nthe array.\n\n```java\nchar[] name = { 'A', 'm', 'a', 'n', 'd', 'a' };\n// m\nSystem.out.println(name[1]);\n```\n\nBut they do not work to perform operations on directly.\n\n```java\n// Will not run\nSystem.out.println({ 'A', 'm', 'a', 'n', 'd', 'a' }[1]);\n```\n", "number": [12, 10], "sub_items": [], "path": "arrays/difference_between_initializer_and_literal.md", "source_path": "arrays/difference_between_initializer_and_literal.md", "parent_names": ["Arrays"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nRemember the rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\n## Challenge 1\n", "number": [12, 11], "sub_items": [], "path": "arrays/challenges.md", "source_path": "arrays/challenges.md", "parent_names": ["Arrays"]}}], "path": "arrays.md", "source_path": "arrays.md", "parent_names": []}}, {"PartTitle": "Control Flow II"}, {"Chapter": {"name": "Loops II", "content": "# Loops II\n\n`while` loops are enough to make any looping logic that you might want, but\nthey aren't the only kind of loops you will see.\n\nThere are tasks which would require a `while` loop, but are common enough that there are other kinds\nof loops that are shortcuts to writing them.\n", "number": [13], "sub_items": [{"Chapter": {"name": "For", "content": "# For\n\nThe `for` loop is a shortcut to writing a `while` loop which\nhas distinct steps that\n\n- Declare a variable\n- Check that variable to know whether to stop iterating\n- Update the variable at the end of each iteration\n\nAs with many things, this might be easiest to see by looking at an example.\n\n```java\n// Will run 10 times\nfor (int number = 0; number < 10; number++) {\n    System.out.println(number);\n}\n```\n\nThat `for` loop works about the same as this `while` loop.\n\n```java\nint number = 0;\nwhile (number < 10) {\n    System.out.println(number);\n\n    number++;\n}\n```\n", "number": [13, 1], "sub_items": [], "path": "loops_ii/for.md", "source_path": "loops_ii/for.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "For Syntax", "content": "# For Syntax\n\nA `for` loop has three distinct parts.\n\n1. An initializer.\n\n2. An expression which evaluates to a `boolean`.\n\n3. A statement.\n\n```java\nfor (<INITIALIZER> ; <EXPRESSION> ; <STATEMENT>) {\n    <CODE HERE>\n}\n```\n\nThe initializer is a statement which declares and initializes a variable\nlike `int number = 0`.\n\nThe expression is some check like `number < 5` that is checked each iteration\nto know if the loop should continue.\n\nThe statement is ran at the end of every iteration, generally updating the variable tracked by the\ninitializer and expression.\n\nThese can be thought of as being the same as a `while` loop written like so.\n\n```java\n<INITIALIZER>;\nwhile (<EXPRESSION>) {\n    <CODE HERE>\n\n    <STATEMENT>;\n}\n```\n", "number": [13, 2], "sub_items": [], "path": "loops_ii/for_syntax.md", "source_path": "loops_ii/for_syntax.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Counting Up and Down", "content": "# Counting Up and Down\n\nOne of the easiest things to do with a `for` loop is count up to or down from\na given number.\n\n```java\n// Goes from 1 to 100\nfor (int currentNumber = 1; currentNumber <= 100; currentNumber++) {\n    System.out.println(currentNumber);\n}\n\n// Goes from 100 to 1\nfor (int currentNumber = 100; currentNumber >= 1; currentNumber--) {\n    System.out.println(currentNumber);\n}\n```\n\nYou use the initializer to set some variable to a starting number like `int currentNumber = 1`,\nhave the expression check if the number is at the target end number like `currentNumber <= 100`,\nand use the statement to change the number by one like `currentNumber++`.[^test]\n\n[^test]:\n    Very often, if you are given a test on `for` loops it will focus on doing all sorts of counting up, down, and around.\n    Be prepared.\n", "number": [13, 3], "sub_items": [], "path": "loops_ii/for_counting_up_and_down.md", "source_path": "loops_ii/for_counting_up_and_down.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Iterate over a String", "content": "# Iterate over a String\n\nAs was shown with `while` loops, being able to count up and down lets\nyou iterate over each character in a `String`.\n\n```java\nString name = \"Lavigne\";\n\nfor (int index = 0; index < name.length(); index++) {\n    System.out.println(name.charAt(index));\n}\n```\n", "number": [13, 4], "sub_items": [], "path": "loops_ii/iterate_over_a_string.md", "source_path": "loops_ii/iterate_over_a_string.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Iterate over an Array", "content": "# Iterate over an Array\n\nIn the same way you can use a `for` loop to go through each character of a `String`,\nyou can use it to go through each element in an array.\n\n```java\nint[] numbers = { 4, 1, 6, 9 };\n\nfor (int index = 0; index < numbers.length; index++) {\n    System.out.println(numbers[index]);\n}\n```\n\nThe only difference from `String`s is that instead of `.length()` and `.charAt(...)`, you use `.length` and `[]`.\n", "number": [13, 5], "sub_items": [], "path": "loops_ii/iterate_over_an_array.md", "source_path": "loops_ii/iterate_over_an_array.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Comparison to while", "content": "# Comparison to while\n\nIf you were to compare the code needed to loop over an array using a `for` loop\nand the code needed with a `while` loop, there might not seem like much of a difference.\n\n```java\ndouble[] numbers = { 4.4, 1.1, 4.1, 4.7 };\n\nfor (int index = 0; index < numbers.length; index++) {\n    System.out.println(numbers[index]);\n}\n\nint index = 0;\nwhile (index < numbers.length) {\n    System.out.println(numbers[index]);\n    index++;\n}\n```\n\nThis is doubly true when we are looking at toy examples where the only thing done\nwith the element is `System.out.println`.\n\nThe biggest benefit to a `for` is subtle. With a `while` based loop, the initializer and boolean expression\ncan potentially be many lines from the statement which updates the variable.\n\n```java\nint index = 0;\nwhile (index < numbers.length) {\n    /*\n    Can\n\n\n    potentially\n\n    have\n\n    arbitrary\n\n    code\n\n    you want to run\n\n    a bunch\n\n    of times\n    */\n\n    index++;\n}\n```\n\nUs humans, with our tiny monkey brains, can get very lost when things that are related to eachother are separated\nby long distances.\n\nIn this dimension, for loops are superior. All the bits of code that \"control the loop\" can be right at the top.\n\n```java\nfor (int index = 0; index < numbers.length; index++) {\n    /*\n    Can\n\n\n    potentially\n\n    have\n\n    arbitrary\n\n    code\n\n    you want to run\n\n    a bunch\n\n    of times\n    */\n}\n```\n", "number": [13, 6], "sub_items": [], "path": "loops_ii/comparison_to_while.md", "source_path": "loops_ii/comparison_to_while.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "i", "content": "# i\n\nOne thing you will very often see if you read other peoples'\ncode is that the variable being tracked in a for loop is often called\n`i`.\n\n```java\nString word = \"bird\";\n\nfor (int i = 0; i < array.length; i++) {\n    char letter = word.charAt(i);\n    System.out.println(letter);\n}\n\n// b\n// i\n// r\n// d\n```\n\nWhile usually naming variables with single letters isn't a great idea,\nmost developers carve out an exception for cases like this. Writing `index` gets\ntedious.\n\nIts also helpful to go `i -> j -> k` when you end up nesting `for` loops.[^jindex]\n\n```java\nchar[] letters = { 'A', 'B', 'C' };\nint[] numbers = { 1, 2 };\n\nfor (int i = 0; i < letters.length; i++) {\n    for (int j = 0; j < numbers.length; j++) {\n        System.out.print(letters[i]);\n        System.out.println(numbers[j]);\n    }\n}\n\n// A1\n// A2\n// B1\n// B2\n// C1\n// C2\n```\n\nJust do not start naming all your variables single letters.\n\n[^jindex]: `j` and `k` standing for jindex an kindex respectfully.\n", "number": [13, 7], "sub_items": [], "path": "loops_ii/i.md", "source_path": "loops_ii/i.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Break", "content": "# Break\n\n`break` works the same with `for` loops as it does with `while` loops.\nAny time you hit a line with `break` you will immediately exit the loop.\n\n```java\nfor (int i = 0; i < 1000; i++) {\n    if (i == 5) {\n        break;\n    }\n    System.out.println(i);\n}\nSystem.out.println(\"Over\");\n\n// 0\n// 1\n// 2\n// 3\n// 4\n// Over\n```\n", "number": [13, 8], "sub_items": [], "path": "loops_ii/break.md", "source_path": "loops_ii/break.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Continue", "content": "# Continue\n\n`continue` works slightly differently with `for` loops than how it does with `while` loops.\n\nAny time you hit a line with `continue` you will immediately jump back to the top of the loop, but\nunlike with a `while` loop, the statement which updates your variable will still run.\n\n```java\nfor (int i = 0; i < 5; i++) {\n    if (i == 2) {\n        // i++ will still run\n        continue;\n    }\n    System.out.println(i);\n}\n\n// 0\n// 1\n// 3\n// 4\n```\n\nSo the above `for` loop is not equivalent to this `while` loop.\n\n```java\nint i = 0;\nwhile (i < 5) {\n    if (i == 2) {\n        continue;\n    }\n    System.out.println(i);\n\n    i++;\n}\n\n// 0\n// 1\n// ... spins forever ...\n```\n\nIt is equivalent to this one.\n\n```java\nint i = 0;\nwhile (i < 5) {\n    if (i == 2) {\n        i++\n        continue;\n    }\n    System.out.println(i);\n\n    i++;\n}\n\n// 0\n// 1\n// 3\n// 4\n```\n", "number": [13, 9], "sub_items": [], "path": "loops_ii/continue.md", "source_path": "loops_ii/continue.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Delayed Assignment", "content": "# Delayed Assignment\n\nThe initializer of a `for` loop can give an initial value to a variable\ndeclared outside of the loop.\n\n```java\nint number;\nfor (number = 0; number < 5; number++) {\n    System.out.println(\"At: \" + number);\n}\n```\n\nYou might choose to do this so that after the loop is finished, you can still access the variable.\n\n```java\nint number;\nfor (number = 0; number < 5; number++) {\n    System.out.println(\"At: \" + number);\n}\n\n// This will work, we can access the variable still.\nSystem.out.println(\"Ended at: \" + number);\n```\n\nIf you had put both the declaration and initial value inside the initializer, you won't be able\nto use that variable after the loop\n\n```java\nfor (int number = 0; number < 5; number++) {\n    System.out.println(\"At: \" + number);\n}\n\n// This will not work. number is no longer available\nSystem.out.println(\"Ended at: \" + number);\n```\n", "number": [13, 10], "sub_items": [], "path": "loops_ii/delayed_assignment.md", "source_path": "loops_ii/delayed_assignment.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Inferred Types", "content": "# Inferred Types\n\nThe initializer of a `for` loop works the same as any variable assignment, so\nyou still are allowed to use `var` so that the type of the declared variable is inferred.\n\n```java\nfor (var i = 0; i < 10; i++) {\n    System.out.println(i);\n}\n```\n\n`var` is the same number of letters as `int` so you aren't gaining much when your `for` loop\nis just counting over numbers.\n\nBut if your `for` loop is doing something more exotic, it might make sense.\n\n```java\nfor (var repeated = \"\"; repeated.length() < 5; repeated = repeated + \"a\") {\n    System.out.println(repeated);\n}\n\n// a\n// aa\n// aaa\n// aaaa\n```\n", "number": [13, 11], "sub_items": [], "path": "loops_ii/inferred_types.md", "source_path": "loops_ii/inferred_types.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Empty Initializers", "content": "# Empty Initializers\n\nYou are allowed to leave the initializer part of a `for` loop blank\nso long as you still have the `;`.\n\n```java\nint number = 0;\nfor (;number < 5; number++) {\n    System.out.println(number);\n}\n```\n\nYou might choose to do this for the same reasons you might choose to split the declaration\nand assignment of the \"loop variable.\" So that the variable will be accessible after the end of the loop.\n\nThis way its initialization and declaration can be on the same line, which might be desirable.\n\n```java\nint number = 0;\nfor (;number < 5; number++) {\n    System.out.println(number);\n}\nSystem.out.println(\"Still have number: \" + number);\n```\n", "number": [13, 12], "sub_items": [], "path": "loops_ii/empty_initializers.md", "source_path": "loops_ii/empty_initializers.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Empty Expressions", "content": "# Empty Expressions\n\nYou are also allowed to leave the expression part of a `for` loop blank.\n\n```java\nfor (int i = 0;;i++) {\n    System.out.println(i);\n}\n// 0\n// 1\n// 2\n// 3\n// ... and so on\n```\n\nThis means that each time through there is no check to see if the loop will exit.\nThe loop will only exit if there is an explicit `break` somewhere.\n\n```java\nfor (int i = 0;;i++) {\n    if (i == 5) {\n        break;\n    }\n    System.out.println(i);\n}\n// 0\n// 1\n// 2\n// 3\n// 4\n```\n", "number": [13, 13], "sub_items": [], "path": "loops_ii/empty_expressions.md", "source_path": "loops_ii/empty_expressions.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Empty Statements", "content": "# Empty Statements\n\nYou can even leave the statement part of a `for` loop blank. This means that at\nthe end of an iteration there is nothing guarenteed to run.\n\n```java\nfor (int i = 6; i > 2;) {\n    System.out.println(i);\n    i--;\n}\n\n// 6\n// 5\n// 4\n// 3\n// 2\n```\n\nIf you leave both the initializer and statement blank, that will be functionally identical to a `while` loop.[^cry]\n\n```java\nint number = 1;\nfor (;number < 10;) {\n    System.out.println(number);\n    number *= 2;\n}\n\n// Same logic as above\nint number2 = 1;\nwhile (number2 < 10) {\n    System.out.println(number2);\n    number2 *= 2;\n}\n```\n\nIf you leave the initializer, expression, and statement blank it will be the same as a `while (true)` loop.\n\n```java\nfor (;;) {\n    System.out.println(\"The people stated singing it...\");\n}\n// Runs forever\n```\n\nThe only difference is that `(;;)` looks somewhat like\n\n- A spider\n- The Pok\u00e9mon Kabuto\n- A person crying\n\nAnd that can be fun.\n", "number": [13, 14], "sub_items": [], "path": "loops_ii/empty_statements.md", "source_path": "loops_ii/empty_statements.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Final Variables", "content": "# Final Variables\n\nThe initializer of a `for` loop can also declare `final` variables.\n\n```java\nint i = 0;\nfor (final String name = \"Bob\"; i < 5; i++) {\n    System.out.println(name + \": \" + i);\n}\n```\n\nThis doesn't have much use with loops that track `int`s and `String`s, but if you\nare feeling clever you can use this ability along with arrays or other things you\ncan change without reassigning a variable.\n\n```java\nfor (final char[] letters = { 'I', 'O', 'U' }; letters[0] != 'A';) {\n    for (int i = 0; i < letters.length; i++) {\n        letters[i] -= 1;\n        System.out.print(letters[i]);\n    }\n    System.out.println();\n}\n\n// HNT\n// GMS\n// FLR\n// EKQ\n// DJP\n// CIO\n// BHN\n// AGM\n```\n\nThere aren't many reasons to do this, but it is in fact not against the law and I cannot stop you.\n", "number": [13, 15], "sub_items": [], "path": "loops_ii/final_variables.md", "source_path": "loops_ii/final_variables.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Labeled Break", "content": "# Labeled Break\n\nLabeled breaks work the same with `for` loops as they do with `while` loops.\n\n```java\nouterLoop:\nfor (;;) {\n    for (;;) {\n        break outerLoop;\n    }\n}\n```\n\nThis applies also to when `while` loops are nested within `for` loops or the other way around.\n\n```java\nouterForLoop:\nfor (int i = 0; i < 10; i++) {\n    System.out.println(i);\n    while (i < 100) {\n        if (i == 5) {\n            break outerForLoop;\n        }\n        i++;\n    }\n    System.out.println(i);\n}\n\n// 0\n```\n", "number": [13, 16], "sub_items": [], "path": "loops_ii/labeled_break.md", "source_path": "loops_ii/labeled_break.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Labeled Continue", "content": "# Labeled Continue\n\nLabeled continues also work the same in `for` loops as `while` loops, but with the hopefully expected caveat that\nthe statement of a `for` loop will always run when you get to the top of it.[^uncommon]\n\n```java\nlabel:\nfor (int i = 0; i < 4; i++) {\n    for (int j = 0; j < 3; j++) {\n        System.out.println (\"\" + i + \", \" + j);\n        if (i == 2) {\n            // i++ will run\n            continue label;\n        }\n    }\n}\n// 0, 0\n// 0, 1\n// 0, 2\n// 1, 0\n// 1, 1\n// 1, 2\n// 2, 0\n// 3, 0\n// 3, 1\n// 3, 2\n```\n", "number": [13, 17], "sub_items": [], "path": "loops_ii/labeled_continue.md", "source_path": "loops_ii/labeled_continue.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Drawing Right Triangles", "content": "# Drawing Right Triangles\n\nOne of the more fun things to do with `for` loops[^quiz] is to use them to print out shapes.\n\nSay you wanted to draw this right triangle.\n\n```\n*\n**\n***\n```\n\nThere is one `*`, then two `*`s on the next line, and three `*`s on the last.\n\nIf you were to write the code out to print this explicitly it would look like this.\n\n```java\nSystem.out.print(\"*\\n**\\n**\\n\");\n```\n\nWhere `\\n` is explicitly putting in the new lines.\n\nSince counting up `1 -> 2 -> 3` is easy with `for` loops, you can translate this\n\n```java\nfor (int numberOfStars = 1; numberOfStars <= 3; numberOfStars++) {\n    for (int i = 0; i < numberOfStars; i++) {\n        System.out.print(\"*\");\n    }\n    // Same as System.out.print(\"\\n\");\n    System.out.println();\n}\n```\n\nWhich makes it easy to make one of these triangles however tall you want.\n\n```java\nint height = 6;\nfor (int numberOfStars = 1; numberOfStars <= height; numberOfStars++) {\n    for (int i = 0; i < numberOfStars; i++) {\n        System.out.print(\"*\");\n    }\n    System.out.println();\n}\n```\n\n```\n*\n**\n***\n****\n*****\n******\n```\n", "number": [13, 18], "sub_items": [], "path": "loops_ii/drawing_right_triangles.md", "source_path": "loops_ii/drawing_right_triangles.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Drawing Isosceles Triangles", "content": "# Drawing Isosceles Triangles\n\nAnother fun shape is the isosceles triangle.\n\n```\n  *\n ***\n*****\n```\n\nFor this one, the each row of the triangle needs to have spaces before it to shift it in to the\ncenter. How much each row needs to be shifted depends on how big the trangle will be overall.\n\nIn this case with three rows of `*`s, the top `*` needs two space characters before it\nand the second row needs one space character.\n\n```java\nSystem.out.println(\"   *\\n  ***\\n*****\");\n```\n\nSo any loop we make needs to take this pattern into account.\n\n```java\nint totalRows = 5;\nfor (int row = 1; row <= totalRows; row++) {\n    for (int i = 0; i < totalRows - row; i++) {\n        System.out.print(\" \");\n    }\n    for (int i = 0; i < row * 2 - 1; i++) {\n        System.out.print(\"*\");\n    }\n    System.out.println();\n}\n```\n\n```\n    *\n   ***\n  *****\n *******\n*********\n```\n\nWhich can get tricky. For now, you can just study the code that does it for this shape. There will be more things to draw\nin the challenges section.[^reason]\n\n[^reason]: The reason I'm focusing on this isn't because its likely you will get a job drawing shapes, but if you can draw a shape [you can dodge a ball](https://www.youtube.com/watch?v=1ZXHsNqkDI4).\n", "number": [13, 19], "sub_items": [], "path": "loops_ii/drawing_isosceles_triangles.md", "source_path": "loops_ii/drawing_isosceles_triangles.md", "parent_names": ["Loops II"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nRemember the rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\nYou are extremely likely to be quizzed on `for` loops on any standardized tests,\nso these challenges are going to include a lot of repetition and sometimes a tricky\ncase to handle. Its for your own good, I hope.\n\n## Challenge 1\n\nWrite code that will output every number from 0 to 15, including 0 and 15.\n\n```\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n```\n\nDo it using a `for` loop and again using a `while` loop.\n\n## Challenge 2\n\nWrite code that will output every number from 15 to 0, including 0 and 15.\n\n```\n15\n14\n13\n12\n11\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n```\n\nDo it using a `for` loop and again using a `while` loop.\n\n## Challenge 3\n\nWrite code that will output every number from 15 to 0, excluding 0 and 15.\n\n```\n14\n13\n12\n11\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n```\n\nDo it using a `for` loop and again using a `while` loop.\n\n## Challenge 4.\n\nWrite code that will output every third number from 51 to 66.\n\n```\n53\n56\n59\n62\n65\n```\n\nDo it using a `for` loop and again using a `while` loop.\n\n## Challenge 5.\n\nDraw a square.\n\nMake it so that you can make the square bigger or smaller by\nchanging a variable at the start of the program.\n\n```\n*****\n*****\n*****\n*****\n```\n\n## Challenge 6.\n\nDraw a rectangle.\n\nMake it so that you can make the rectangle bigger or smaller in either dimension by\nchanging a variable at the start of the program.\n\n```\n******\n******\n******\n```\n\n## Challenge 7.\n\nDraw a circle!\n\nMake it so that you can make the circle bigger or smaller by\nchanging a variable at the start of the program.\n\n```\n    **\n   ****\n  ******\n ********\n  ******\n   ****\n    **\n```\n\n## Challenge 8.\n\nDraw a smiley face!\n\nMake it so that you can make the smile bigger or smaller by\nchanging a variable at the start of the program.\n", "number": [13, 20], "sub_items": [], "path": "loops_ii/challenges.md", "source_path": "loops_ii/challenges.md", "parent_names": ["Loops II"]}}], "path": "loops_ii.md", "source_path": "loops_ii.md", "parent_names": []}}, {"PartTitle": "Code Structure"}, {"Chapter": {"name": "Methods", "content": "# Methods\n\nAll the code you have seen up until this point has lived inside of `void main() {}`.\n\n```java\nvoid main() {\n    System.out.println(\"CODE GO HERE\");\n}\n```\n\nThis isn't sustainable for a few reasons. One is that code can get big. Putting a thousand lines inside of one place can be a lot, let\nalone the hundreds of thousands you need to be Minecraft or the millions you need to be Google.\n\nAnother is that there is almost always code that you will want to run at multiple places in a program.\nCopy pasting that code can get old.\n\nThis is what methods are for. Methods let you split up your code into smaller, reusable chunks.[^def]\n\n[^def]: The word method comes from a \"method of getting things done.\" You might also hear methods referred to as \"functions\".\n", "number": [14], "sub_items": [{"Chapter": {"name": "Declaration", "content": "# Declaration\n\nThe simplest kind of method is declared by writing `void` followed by some name, `()`, and some code inside of a `{` and `}`.\n\n```java\nvoid doThing() {\n    System.out.println(\"Hello from inside a method!\");\n}\n```\n", "number": [14, 1], "sub_items": [], "path": "methods/declaration.md", "source_path": "methods/declaration.md", "parent_names": ["Methods"]}}, {"Chapter": {"name": "Invocation", "content": "# Invocation\n\nOnce you've declared a method you can run the code inside of it by writing the\nname of the method followed by `()` in a statement.\n\n```java\nvoid doThing() {\n    System.out.println(\"Hello from inside a method!\");\n}\n\nvoid main() {\n    doThing();\n}\n```\n\nRunning the code in a method can be called a few things. \"Running a method\", \"Calling a method\", or \"Invoking a method.\"[^wizard]\n\nYou can call a method multiple times. If you do, then the code inside of it will be run multiple times.\n\n```java\nvoid doThing() {\n    System.out.println(\"Hello from inside a method!\");\n}\n\nvoid main() {\n    doThing();\n    doThing();\n}\n```\n\n[^wizard]: I like that last one because \"invoking\" makes me sound like a Wizard.\n", "number": [14, 2], "sub_items": [], "path": "methods/invocation.md", "source_path": "methods/invocation.md", "parent_names": ["Methods"]}}, {"Chapter": {"name": "Scope", "content": "# Scope\n\nMethods can contain any code, including variable declarations.\n\n```java\nvoid sayMathStuff() {\n    int x = 1;\n    int y = 2;\n    System.out.println(\"x is \" + x);\n    System.out.println(\"y is \" + y);\n    System.out.println(\"x + y is \" + (x + y));\n}\n\nvoid main() {\n    sayMathStuff();\n}\n```\n\nWhen a method declares a variable inside of its body, that declaration is \"scoped\" to that method.\nOther code cannot see that variable.\n\n```java\nvoid sayMathStuff() {\n    int x = 1;\n    int y = 2;\n    System.out.println(\"x is \" + x);\n    System.out.println(\"y is \" + y);\n    System.out.println(\"x + y is \" + (x + y));\n}\n\nvoid main() {\n    sayMathStuff();\n    // Error, x doesn't exist here\n    System.out.println(x);\n}\n```\n\nThis is why we have called variables \"local variables.\" They are local to the \"scope\" of the\nmethod they are declared in.\n", "number": [14, 3], "sub_items": [], "path": "methods/scope.md", "source_path": "methods/scope.md", "parent_names": ["Methods"]}}, {"Chapter": {"name": "Return", "content": "# Return\n\nAnywhere inside of a method you can write `return` to immediately exit that method.\n\n```java\nvoid willReturnEarly() {\n    for (int i = 0; i < 10; i++) {\n        System.out.println(i);\n        if (i == 5) {\n            // Will stop at 5 because we exit the method\n            return;\n        }\n    }\n\n    System.out.println(\"THIS WONT RUN\");\n}\n\nvoid main() {\n    willReturnEarly();\n}\n```\n\nThis will break out of any loops and skip running any other code in the method.\n\n```java\nvoid escapeFromLoops() {\n    while (true) {\n        for (;;) {\n            for (;;) {\n                while (true) {\n                    // Escape!\n                    return;\n                }\n            }\n        }\n    }\n}\n\nvoid main() {\n    escapeFromLoops();\n}\n```\n", "number": [14, 4], "sub_items": [], "path": "methods/return.md", "source_path": "methods/return.md", "parent_names": ["Methods"]}}, {"Chapter": {"name": "Unreachable Statements", "content": "# Unreachable Statements\n\nIf Java can figure out that some line of code is unreachable because it will always come after a\n`return`, then it will not run your code.\n\n```java\nvoid doThing() {\n    System.out.println(\"A\");\n    return;\n    // unreachable statement\n    System.out.println(\"B\");\n}\n\nvoid main() {\n    doThing();\n}\n```\n\nJava is easy to trick though.[^trick]\n\n```java\nvoid doThing() {\n    System.out.println(\"A\");\n    if (true) {\n        return;\n    }\n    System.out.println(\"B\");\n}\n\nvoid main() {\n    doThing();\n}\n```\n\n[^trick]: This _will_ always return before the `println`, but Java chooses to not figure that out. It can't be smart enough to see through every `if`, so it doesn't try for any of them.\n", "number": [14, 5], "sub_items": [], "path": "methods/unreachable_statements.md", "source_path": "methods/unreachable_statements.md", "parent_names": ["Methods"]}}, {"Chapter": {"name": "main", "content": "# main\n\nThe `main` method works the same as any other method. Java just treats it special by choosing to\ncall it in order to start your programs.\n\n```java\nvoid main() {\n    System.out.println(\"Java will start here\");\n}\n```\n\nThis means you can do anything in your `main` method you can do in any other method, including returning early.\n\n```java\nvoid main() {\n    int x = 5;\n\n    if (x == 5) {\n        return;\n    }\n\n    System.out.println(\"WONT RUN\");\n}\n```\n", "number": [14, 6], "sub_items": [], "path": "methods/main.md", "source_path": "methods/main.md", "parent_names": ["Methods"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nRemember the rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\n## Challenge 1.\n\nDeclare a method named `printSquare`. When invoked it should print a square.\n\n```java\n// CODE HERE\n\nvoid main() {\n    printSquare();\n}\n```\n\n## Challenge 2.\n\nDeclare a method named `printSquareThreeTimes`. When invoked it should print three squares\nby invoking a method named `printSquare` three times.\n\n```java\n// CODE HERE\n\n// Code from challenge 1 here\n\nvoid main() {\n    printSquareThreeTimes();\n}\n```\n\n## Challenge 3.\n\nWrite a program that contains at least four methods. Have fun with it.\n\n```java\nvoid main() {\n    // sing a song or something.\n}\n```\n", "number": [14, 7], "sub_items": [], "path": "methods/challenges.md", "source_path": "methods/challenges.md", "parent_names": ["Methods"]}}], "path": "methods.md", "source_path": "methods.md", "parent_names": []}}, {"Chapter": {"name": "Arguments", "content": "# Arguments\n\nIf methods always had to do the same thing each time they were run, they wouldn't be that useful.\n\nThe way to customize what happens when a method is called is to have them take \"arguments.\"\n\n```java\nvoid sayHello(String name) {\n    System.out.println(\"Hello \" + name + \"!\");\n}\n\nvoid main() {\n    // Hello Joshua!\n    sayHello(\"Joshua\");\n    // Hello Claire!\n    sayHello(\"Claire\");\n}\n```\n", "number": [15], "sub_items": [{"Chapter": {"name": "Declaration", "content": "# Declaration\n\nTo declare a method which takes arguments, instead of putting `()` after the method name\nyou need to put a comma separated list of argument declarations.\n\nEach argument declaration looks the same as a variable declaration and has both a type and a name.\n\n```java\n// This declares a single argument named \"food\" that\n// has a type of \"String\".\nvoid eat(String food) {\n    System.out.println(\"I ate \" + food);\n}\n\n// This declares two arguments\n// \"to\", which is a String and\n// \"age\", which is an int.\nvoid happyBirthday(String to, int age) {\n    System.out.println(\n        \"Happy \" + age + \"th birthday \" + to + \"!\"\n    );\n}\n```\n", "number": [15, 1], "sub_items": [], "path": "arguments/declaration.md", "source_path": "arguments/declaration.md", "parent_names": ["Arguments"]}}, {"Chapter": {"name": "Invocation with Arguments", "content": "# Invocation with Arguments\n\nTo invoke a method which takes arguments you need to, instead of writing\n`()` after the method name, write `(` followed by a comma separated list\nof literals or variable names ending with `)`.\n\n```java\nvoid eat(String food) {\n    System.out.println(\"I ate \" + food);\n}\n\nvoid happyBirthday(String to, int age) {\n    System.out.println(\n        \"Happy \" + age + \"th birthday \" + to + \"!\"\n    );\n}\n\nvoid main() {\n    // This calls the 'eat' method with the String \"cake\"\n    // as an argument.\n    eat(\"Cake\");\n\n    // You can also call methods using values stored in\n    // variables.\n    String veggie = \"carrot\";\n    eat(veggie);\n\n    // For more than one argument, you separate them with commas\n    happyBirthday(\"Charlotte\", 24);\n}\n```\n", "number": [15, 2], "sub_items": [], "path": "arguments/invocation_with_arguments.md", "source_path": "arguments/invocation_with_arguments.md", "parent_names": ["Arguments"]}}, {"Chapter": {"name": "Reassignment", "content": "# Reassignment\n\nInside of a method, arguments work the same as normal variable declarations.\nThis means that their value can be reassigned\nwithin the method body;\n\n```java\nvoid eat(String food) {\n    System.out.println(\"I ate \" + food);\n    food = \"nothing\";\n    System.out.println(\"Now I have \" + food)\n}\n\nvoid main() {\n    eat(\"Cake\");\n}\n```\n\nReassigning an argument's value will not affect the value assigned to\nany variables passed to the method by the caller.\n\n```java\nvoid eat(String food) {\n    System.out.println(\"I ate \" + food);\n    food = \"nothing\";\n    System.out.println(\"Now I have \" + food)\n}\n\nvoid main() {\n    String fruit = \"apple\";\n    eat(fruit);\n    System.out.println(\n        \"But in the caller I still have an \" + fruit\n    );\n}\n```\n", "number": [15, 3], "sub_items": [], "path": "arguments/reassignment.md", "source_path": "arguments/reassignment.md", "parent_names": ["Arguments"]}}, {"Chapter": {"name": "Final Arguments", "content": "# Final Arguments\n\nJust like normal variable declarations, arguments can be marked\n`final`. This makes it so that they cannot be reassigned.\n\n```java\nvoid eat(final String food) {\n    System.out.println(\"I ate \" + food);\n}\n\nvoid main() {\n    eat(\"Welsh Rarebit\");\n}\n```\n\nIf you try to reassign a final argument, Java will not accept your program.\n\n```java\nvoid eat(final String food) {\n    System.out.println(\"I ate \" + food);\n    // Will not work\n    food = \"toast\";\n    System.out.println(food);\n}\n\nvoid main() {\n    eat(\"Welsh Rarebit\");\n}\n```\n\nThis has the same use as regular final variables. If there are lots of lines\nof code where a variable might be reassigned, it can be useful to not have\nto read all that code to know that it does happen.[^opinion]\n\n[^opinion]:\n    Adding `final` to all arguments can make it harder to read the code, simply\n    because of visual noise.\n", "number": [15, 4], "sub_items": [], "path": "arguments/final_arguments.md", "source_path": "arguments/final_arguments.md", "parent_names": ["Arguments"]}}, {"Chapter": {"name": "Aliasing", "content": "# Aliasing\n\nBecause arguments work like variables, if you pass something\nlike an array as an argument the array referenced by the argument will be the exact same as the array referenced by the variable given to the method.\n\n```java\nvoid incrementFirst(int[] numbers) {\n    numbers[0] = numbers[0] + 1;\n}\n\nvoid main() {\n    int nums = new int[] { 8 };\n\n    // The first number is 8\n    System.out.println(\n        \"The first number is \" + nums[0]\n    );\n\n    incrementFirst(nums);\n\n    // Now it is 9\n    System.out.println(\n        \"Now it is \" + nums[0]\n    );\n}\n```\n\nThe argument aliases the value passed to the method.\n", "number": [15, 5], "sub_items": [], "path": "arguments/aliasing.md", "source_path": "arguments/aliasing.md", "parent_names": ["Arguments"]}}, {"Chapter": {"name": "Overloading", "content": "# Overloading\n\nMultiple methods can be declared that have the same name.\nThis is allowed so long as each method takes different types\nor different numbers of arguments.\n\n```java\nvoid doThing(int x) {\n    System.out.println(x);\n}\n\nvoid doThing(String name) {\n    System.out.println(\"Hello \" + name);\n}\n\nvoid doThing(int x, int y) {\n    System.out.println(x + y);\n}\n```\n\nWhen you call the method, Java will know what code to run\nbecause it knows the types of and number of arguments\nyou are passing.\n\n```java\nvoid main() {\n    // Java can figure out what to do\n    doThing(1);\n    doThing(\"abc\");\n    doThing(1, 2);\n}\n```\n\nWhen there are multiple methods that have the same name but take different arguments,\nthose methods are considered \"overloads\" of eachother[^overload]\n\n[^overload]:\n    \"Overloading\" in this context means when one word has more than\n    one possible meaning depending on how it is used. Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo.\n", "number": [15, 6], "sub_items": [], "path": "arguments/overloading.md", "source_path": "arguments/overloading.md", "parent_names": ["Arguments"]}}, {"Chapter": {"name": "Inferred Types", "content": "# Inferred Types\n\nWith variable declarations, you can use `var` to let Java figure out the type\nof the variable.\n\n```java\nvar name = \"Jupiter\";\n```\n\nThis is _not_ allowed with argument declarations.\n\n```java\n// You aren't allowed to use var for arguments!\nvoid makeHorchata(var milkFatPercent) {\n    // ...\n}\n```\n\nYou must always explicitly write out the types of arguments.\n\n```java\nvoid makeHorchata(double milkFatPercent) {\n    System.out.println(\n        \"Making a horchata with \" + milkFatPercent + \"% milk.\"\n    );\n}\n```\n", "number": [15, 7], "sub_items": [], "path": "arguments/inferred_types.md", "source_path": "arguments/inferred_types.md", "parent_names": ["Arguments"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nRemember the rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\n## Challenge 1.\n\nWrite a method named `printSquare` which takes one `int` argument named `size`.\n\nThe `size` argument should control how big of a square is output.\n\n```java\n// CODE HERE\n\nvoid main() {\n    printSquare(4);\n    System.out.println();\n\n    printSquare(3);\n    System.out.println();\n\n    printSquare(2);\n    System.out.println();\n\n    printSquare(1);\n    System.out.println();\n}\n```\n\n## Challenge 2.\n\nWhat happens if a negative number is given to your `printSquare`?\n\nMake it so that if a negative number is given, it works the same as if a positive number\nwas given.\n\n```java\n// CODE HERE\n\nvoid main() {\n    printSquare(3);\n    System.out.println();\n    printSquare(-3);\n    System.out.println();\n\n    System.out.println();\n    printSquare(-2);\n    System.out.println();\n    printSquare(2);\n}\n```\n\n## Challenge 3.\n", "number": [15, 8], "sub_items": [], "path": "arguments/challenges.md", "source_path": "arguments/challenges.md", "parent_names": ["Arguments"]}}], "path": "arguments.md", "source_path": "arguments.md", "parent_names": []}}, {"Chapter": {"name": "Return Values", "content": "# Return Values\n\nIn addition to running some code, a method can return a value to the code that is calling it.\n\nTo do this, instead of writing `void` before a method, you should write the name of a type like `int`.\nThen at the end of the method you need to write `return` followed by something which is that type.\n\n```java\nint returnsEight() {\n    return 8;\n}\n```\n\nWhen the method is called, that expression can be used on the right hand side of an `=` to get the value returned by the method.\n\n```java\nint returnsEight() {\n    return 8;\n}\n\nvoid main() {\n    int value = returnsEight();\n    System.out.println(value);\n}\n```\n\nThe method call can also be used directly in expressions without assigning its value to a variable first.\n\n```java\nString returnsName() {\n    return \"Mariah\";\n}\n\nvoid main() {\n    System.out.println(returnsName() + \" is my name\");\n}\n```\n", "number": [16], "sub_items": [{"Chapter": {"name": "void", "content": "# void\n\nAll methods have to declare some return type. `void` is what you write when a method won't return any value.\n\n```java\n// Returns a String\nString title() {\n    return \"All Night\";\n}\n\n// Returns an int\nint views() {\n    return 4071;\n}\n\n// Doesn't return any value.\nvoid talkAboutVideo() {\n    System.out.println(title() + \" only has \" + views() + \" views.\");\n}\n\n// This is what the void in \"void main()\" means\nvoid main() {\n    talkAboutVideo();\n}\n```\n", "number": [16, 1], "sub_items": [], "path": "return_values/void.md", "source_path": "return_values/void.md", "parent_names": ["Return Values"]}}, {"Chapter": {"name": "Conversion", "content": "# Conversion\n\nWhen a value is returned, Java will want to coerce it into\nthe type of value that the method says it returns.\n\nIf Java knows how to do that conversion, then it can happen automatically.\n\n```java\n// This method declares a return type of double.\ndouble returnFive() {\n    // x is an int\n    int x = 5;\n    // When it is returned, it will be turned into a double\n    return x;\n}\n```\n\nBut if that conversion might potentially be lossy or, as with converting `double`s to `int`s,\nyou must do it yourself.\n\n```java\ndouble returnNine() {\n    double nine = 9.0;\n    // The (int) explicitly converts the double to an int\n    return (int) nine;\n}\n```\n", "number": [16, 2], "sub_items": [], "path": "return_values/conversion.md", "source_path": "return_values/conversion.md", "parent_names": ["Return Values"]}}, {"Chapter": {"name": "Pure Functions", "content": "# Pure Functions\n\nWhen a method only uses its arguments in order to compute a return value\nbut doesn't otherwise change the outside world, we call those methods\n\"pure functions.\"\n\n```java\n// square just uses x to compute the square of x\nint square(int x) {\n    return x * x;\n}\n```\n\nIf a method changes any values non-local to it, such as by assigning values to an array,\nwe consider it to be \"impure.\"\n\n```java\nvoid multiplyAllByTwo(int[] numbers) {\n    for (int i = 0; i < numbers.length; i++) {\n        // This assignment is \"impure\" since it changes\n        // something outside the method.\n        numbers[i] = numbers[i] * 2;\n    }\n}\n```\n\nThe term \"pure\" comes from the notion of \"pure mathematics.\"\n\nPure functions are useful in the sense that they can be easier to understand on account of having what\nthey do only depend on their inputs.\n\nThey can also be easier to verify. To know if a pure function does\nwhat you expect it to, you can give it example arguents and check to see that its return values are what\nyou expect.\n", "number": [16, 3], "sub_items": [], "path": "return_values/pure_functions.md", "source_path": "return_values/pure_functions.md", "parent_names": ["Return Values"]}}, {"Chapter": {"name": "Impure Functions", "content": "# Impure Functions\n", "number": [16, 4], "sub_items": [], "path": "return_values/impure_functions.md", "source_path": "return_values/impure_functions.md", "parent_names": ["Return Values"]}}], "path": "return_values.md", "source_path": "return_values.md", "parent_names": []}}, {"PartTitle": "User Input"}, {"Chapter": {"name": "User Input", "content": "# User Input\n\nUp until now all the code you have written has been \"in its' own world.\"\n", "number": [17], "sub_items": [], "path": "user_input.md", "source_path": "user_input.md", "parent_names": []}}, {"PartTitle": "Data Types III"}, {"Chapter": {"name": "Identity Types", "content": "# Identity Types\n", "number": [18], "sub_items": [{"Chapter": {"name": "Comparison with ==", "content": "# Comparison with ==\n", "number": [18, 1], "sub_items": [], "path": "identity_types/comparison_with_equalsequals.md", "source_path": "identity_types/comparison_with_equalsequals.md", "parent_names": ["Identity Types"]}}], "path": "identity_types.md", "source_path": "identity_types.md", "parent_names": []}}, {"Chapter": {"name": "Primitive Types", "content": "# Primitive Types\n", "number": [19], "sub_items": [], "path": "primitive_types.md", "source_path": "primitive_types.md", "parent_names": []}}, {"Chapter": {"name": "null", "content": "# null\n\nThere is a special value called `null` which is assignable to\nany `String`\n", "number": [20], "sub_items": [{"Chapter": {"name": "Checking for null", "content": "# Checking for null\n", "number": [20, 1], "sub_items": [], "path": "null/checking_for_null.md", "source_path": "null/checking_for_null.md", "parent_names": ["null"]}}, {"Chapter": {"name": "Field Access", "content": "# Field Access\n", "number": [20, 2], "sub_items": [], "path": "null/field_access.md", "source_path": "null/field_access.md", "parent_names": ["null"]}}, {"Chapter": {"name": "Instance Methods", "content": "# Instance Methods\n", "number": [20, 3], "sub_items": [], "path": "null/instance_methods.md", "source_path": "null/instance_methods.md", "parent_names": ["null"]}}], "path": "null.md", "source_path": "null.md", "parent_names": []}}, {"Chapter": {"name": "Boxed Primitives", "content": "# Boxed Primitives\n", "number": [21], "sub_items": [{"Chapter": {"name": "Primitive Types", "content": "# Primitives\n\n`int`, `double`, `char`, and `bool` are classified as \"primitive types.\n\n1. Using `==`will tell you\n\nand types like `String` or `int[]` are\n", "number": [21, 1], "sub_items": [], "path": "boxed_primitives/primitive_types.md", "source_path": "boxed_primitives/primitive_types.md", "parent_names": ["Boxed Primitives"]}}, {"Chapter": {"name": "Integer", "content": "# Integer\n", "number": [21, 2], "sub_items": [], "path": "boxed_primitives/integer.md", "source_path": "boxed_primitives/integer.md", "parent_names": ["Boxed Primitives"]}}, {"Chapter": {"name": "Double", "content": "# Double\n", "number": [21, 3], "sub_items": [], "path": "boxed_primitives/double.md", "source_path": "boxed_primitives/double.md", "parent_names": ["Boxed Primitives"]}}, {"Chapter": {"name": "Character", "content": "# Character\n", "number": [21, 4], "sub_items": [], "path": "boxed_primitives/character.md", "source_path": "boxed_primitives/character.md", "parent_names": ["Boxed Primitives"]}}, {"Chapter": {"name": "Boolean", "content": "# Boolean\n", "number": [21, 5], "sub_items": [], "path": "boxed_primitives/boolean.md", "source_path": "boxed_primitives/boolean.md", "parent_names": ["Boxed Primitives"]}}, {"Chapter": {"name": "Unboxing Conversion", "content": "# Unboxing Conversion\n", "number": [21, 6], "sub_items": [], "path": "boxed_primitives/unboxing_conversion.md", "source_path": "boxed_primitives/unboxing_conversion.md", "parent_names": ["Boxed Primitives"]}}, {"Chapter": {"name": "Boxing Conversion", "content": "# Boxing Conversion\n", "number": [21, 7], "sub_items": [], "path": "boxed_primitives/boxing_conversion.md", "source_path": "boxed_primitives/boxing_conversion.md", "parent_names": ["Boxed Primitives"]}}, {"Chapter": {"name": "Arrays of Boxed Primitives", "content": "# Arrays of Boxed Primitives\n", "number": [21, 8], "sub_items": [], "path": "boxed_primitives/arrays_of_boxed_primitives.md", "source_path": "boxed_primitives/arrays_of_boxed_primitives.md", "parent_names": ["Boxed Primitives"]}}, {"Chapter": {"name": "Challenges", "content": "# Challenges\n\nRemember the rules for this are\n\n- Try to use only the information given up to this point in this book.\n- Try not to give up until you've given it a solid attempt\n\n## Challenge 1.\n\nWrite a method named `printSquare` which takes one `int` argument named `size`.\n\nThe `size` argument should control how big of a square is output.\n\n```java\n// CODE HERE\n\nvoid main() {\n    printSquare(4);\n    System.out.println();\n\n    printSquare(3);\n    System.out.println();\n\n    printSquare(2);\n    System.out.println();\n\n    printSquare(1);\n    System.out.println();\n}\n```\n\n## Challenge 2.\n\nWhat happens if a negative number is given to your `printSquare`?\n\nMake it so that if a negative number is given, it works the same as if a positive number\nwas given.\n\n```java\n// CODE HERE\n\nvoid main() {\n    printSquare(3);\n    System.out.println();\n    printSquare(-3);\n    System.out.println();\n\n    System.out.println();\n    printSquare(-2);\n    System.out.println();\n    printSquare(2);\n}\n```\n\n## Challenge 3.\n", "number": [21, 9], "sub_items": [], "path": "arguments/challenges.md", "source_path": "arguments/challenges.md", "parent_names": ["Boxed Primitives"]}}], "path": "boxed_primitives.md", "source_path": "boxed_primitives.md", "parent_names": []}}, {"Chapter": {"name": "Arrays II", "content": "# Arrays II\n", "number": [22], "sub_items": [{"Chapter": {"name": "Default Values", "content": "# Default Values\n", "number": [22, 1], "sub_items": [], "path": "arrays_ii/default_values.md", "source_path": "arrays_ii/default_values.md", "parent_names": ["Arrays II"]}}, {"Chapter": {"name": "Populate Array", "content": "", "number": [22, 2], "sub_items": [], "path": null, "source_path": null, "parent_names": ["Arrays II"]}}], "path": "arrays_ii.md", "source_path": "arrays_ii.md", "parent_names": []}}, {"PartTitle": "Code Structure II"}, {"Chapter": {"name": "Classes", "content": "# Classes\n\nUp until now all the data types you have used - `int`, `String`, etc. -\ncame with Java. This works for awhile, but eventually you will want or need to define your own types.\n\nThe way to do this is with a \"class.\"\n\n```java\nclass Person {\n\n}\n```\n\nEvery\nA class can be thought of as a \"blueprint\" for making an\nto represent things in your programs.\n\nMethods can only have one return value. This means that if you wanted to make a method\nthat returned two values, such as the location of buried treasure, you would have trouble.\n\n```java\n// Can only declare one \"thing\" that will be returned\ndouble getTreasureLocation() {\n    // Can't return two values.\n    return 43.8803, 103.4538\n}\n```\n\nThis is the first[^many] use of classes. You can declare your own class which can hold multiple\nvalues and use that to smuggle them across a method return.\n\n```java\nclass Location {\n    double latitude;\n    double longitude;\n}\n\nLocation getTreasureLocation() {\n    Location treasure = new Location();\n    treasure.latitude = 43.8803;\n    treasure.longitude = 103.4538;\n    return treasure;\n}\n\nvoid main() {\n    Location treasure = getTreasureLocation();\n\n    System.out.println(\n        \"The treasure is at \" +\n        treasure.latitude +\n        \"N, \" +\n        treasure.longitude +\n        \"W.\"\n    );\n}\n```\n\n[^many]: of many\n", "number": [23], "sub_items": [{"Chapter": {"name": "Class Declaration", "content": "# Class Declaration\n", "number": [23, 1], "sub_items": [], "path": "classes/class_declaration.md", "source_path": "classes/class_declaration.md", "parent_names": ["Classes"]}}, {"Chapter": {"name": "User Defined Types", "content": "# User Defined Types\n\nDeclaring a class\n", "number": [23, 2], "sub_items": [], "path": "classes/user_defined_types.md", "source_path": "classes/user_defined_types.md", "parent_names": ["Classes"]}}, {"Chapter": {"name": "Naming Classes", "content": "# Naming Classes\n", "number": [23, 3], "sub_items": [], "path": "classes/naming_classes.md", "source_path": "classes/naming_classes.md", "parent_names": ["Classes"]}}, {"Chapter": {"name": "Field Declaration", "content": "# Field Declaration\n", "number": [23, 4], "sub_items": [], "path": "classes/field_declaration.md", "source_path": "classes/field_declaration.md", "parent_names": ["Classes"]}}, {"Chapter": {"name": "Field Access", "content": "# Field Access\n", "number": [23, 5], "sub_items": [], "path": "classes/field_access", "source_path": "classes/field_access", "parent_names": ["Classes"]}}, {"Chapter": {"name": "Naming Fields", "content": "# Naming Fields\n\nFields are generally named `camelCase`, the same as local variables.[^break]\n\n```java\nclass Example {\n    int x;\n    String name;\n    int[] timesOfRacers;\n    String[] namesOfClowns;\n}\n```\n\n[^break]: If you break a social rule, something Bad happens.\n", "number": [23, 6], "sub_items": [], "path": "classes/naming_fields.md", "source_path": "classes/naming_fields.md", "parent_names": ["Classes"]}}, {"Chapter": {"name": "new", "content": "# new\n", "number": [23, 7], "sub_items": [], "path": "classes/new.md", "source_path": "classes/new.md", "parent_names": ["Classes"]}}, {"Chapter": {"name": "Zero Values", "content": "# Zero Values\n", "number": [23, 8], "sub_items": [], "path": "classes/zero_values.md", "source_path": "classes/zero_values.md", "parent_names": ["Classes"]}}, {"Chapter": {"name": "Aliasing", "content": "# Aliasing\n", "number": [23, 9], "sub_items": [], "path": "classes/aliasing.md", "source_path": "classes/aliasing.md", "parent_names": ["Classes"]}}, {"Chapter": {"name": "null", "content": "# null\n", "number": [23, 10], "sub_items": [], "path": "classes/null.md", "source_path": "classes/null.md", "parent_names": ["Classes"]}}], "path": "classes.md", "source_path": "classes.md", "parent_names": []}}, {"Chapter": {"name": "Constructors", "content": "# Constructors\n", "number": [24], "sub_items": [{"Chapter": {"name": "this", "content": "# this\n", "number": [24, 1], "sub_items": [], "path": "constructors/this.md", "source_path": "constructors/this.md", "parent_names": ["Constructors"]}}, {"Chapter": {"name": "The Default Constructor", "content": "# The Default Constructor\n", "number": [24, 2], "sub_items": [], "path": "constructors/the_default_constructor.md", "source_path": "constructors/the_default_constructor.md", "parent_names": ["Constructors"]}}, {"Chapter": {"name": "Final Fields", "content": "# Final Fields\n", "number": [24, 3], "sub_items": [], "path": "constructors/final_fields.md", "source_path": "constructors/final_fields.md", "parent_names": ["Constructors"]}}, {"Chapter": {"name": "Multiple Constructors", "content": "# Multiple Constructors\n", "number": [24, 4], "sub_items": [], "path": "constructors/multiple_constructors.md", "source_path": "constructors/multiple_constructors.md", "parent_names": ["Constructors"]}}], "path": "constructors.md", "source_path": "constructors.md", "parent_names": []}}, {"Chapter": {"name": "Instance Methods", "content": "# Instance Methods\n", "number": [25], "sub_items": [{"Chapter": {"name": "Declaration", "content": "# Declaration\n", "number": [25, 1], "sub_items": [], "path": "instance_methods/declaration.md", "source_path": "instance_methods/declaration.md", "parent_names": ["Instance Methods"]}}, {"Chapter": {"name": "Invocation", "content": "# Invocation\n", "number": [25, 2], "sub_items": [], "path": "instance_methods/invocation.md", "source_path": "instance_methods/invocation.md", "parent_names": ["Instance Methods"]}}, {"Chapter": {"name": "this", "content": "# this\n", "number": [25, 3], "sub_items": [], "path": "instance_methods/this.md", "source_path": "instance_methods/this.md", "parent_names": ["Instance Methods"]}}, {"Chapter": {"name": "Aliasing", "content": "# Aliasing\n", "number": [25, 4], "sub_items": [], "path": "instance_methods/aliasing.md", "source_path": "instance_methods/aliasing.md", "parent_names": ["Instance Methods"]}}, {"Chapter": {"name": "Derived Values", "content": "# Derived Values\n", "number": [25, 5], "sub_items": [], "path": "instance_methods/derived_values.md", "source_path": "instance_methods/derived_values.md", "parent_names": ["Instance Methods"]}}], "path": "instance_methods.md", "source_path": "instance_methods.md", "parent_names": []}}, {"Chapter": {"name": "Documentation", "content": "", "number": [26], "sub_items": [{"Chapter": {"name": "Documentation Comments", "content": "", "number": [26, 1], "sub_items": [], "path": null, "source_path": null, "parent_names": ["Documentation"]}}], "path": null, "source_path": null, "parent_names": []}}, {"Chapter": {"name": "Testing", "content": "", "number": [27], "sub_items": [], "path": null, "source_path": null, "parent_names": []}}, {"Chapter": {"name": "Example: \"Growable\" Array", "content": "", "number": [28], "sub_items": [], "path": null, "source_path": null, "parent_names": []}}, {"PartTitle": "User Defined Types"}, {"Chapter": {"name": "Primitive Classes", "content": "# Primitive Classes\n", "number": [29], "sub_items": [], "path": "classes/primitive_classes.md", "source_path": "classes/primitive_classes.md", "parent_names": []}}, {"Chapter": {"name": "Reference Classes", "content": "# Reference Classes\n", "number": [30], "sub_items": [], "path": "classes/reference_classes.md", "source_path": "classes/reference_classes.md", "parent_names": []}}], "__non_exhaustive": null}]